
/*  A Bison parser, made from control.y  */

#define	WORD	258
#define	STRING	259
#define	FLOAT	260
#define	INTEGER	261
#define	ABORT	262
#define	APROPOS	263
#define	BREAK	264
#define	CHDIR	265
#define	DEFINE	266
#define	DELETE	267
#define	DO	268
#define	EDIT	269
#define	ELSE	270
#define	FOREACH	271
#define	HELP	272
#define	HISTORY	273
#define	IF	274
#define	KEY	275
#define	LIST	276
#define	LOCAL	277
#define	MACRO	278
#define	OVERLOAD	279
#define	PRINT	280
#define	PROMPT	281
#define	QUIT	282
#define	READ	283
#define	RESTORE	284
#define	SAVE	285
#define	SET	286
#define	SNARK	287
#define	STANDARD	288
#define	TERMTYPE	289
#define	VERBOSE	290
#define	WHILE	291
#define	WRITE	292
#define	ANGLE	293
#define	ASPECT	294
#define	AXIS	295
#define	BOX	296
#define	CONNECT	297
#define	CONTOUR	298
#define	CTYPE	299
#define	CURSOR	300
#define	DATA	301
#define	DEVICE	302
#define	DOT	303
#define	DRAW	304
#define	DITHER	305
#define	ERASE	306
#define	ERRORBAR	307
#define	EXPAND	308
#define	FORMAT	309
#define	GRID	310
#define	HISTOGRAM	311
#define	IMAGE	312
#define	LABEL	313
#define	LEVELS	314
#define	LIMITS	315
#define	LINES	316
#define	LOCATION	317
#define	LTYPE	318
#define	LWEIGHT	319
#define	MINMAX	320
#define	NOTATION	321
#define	PAGE	322
#define	POINTS	323
#define	PTYPE	324
#define	PUTLABEL	325
#define	RANGE	326
#define	RELOCATE	327
#define	RETURN	328
#define	SHADE	329
#define	SORT	330
#define	SPLINE	331
#define	SURFACE	332
#define	TABLE	333
#define	TICKSIZE	334
#define	USER	335
#define	VIEWPOINT	336
#define	WHATIS	337
#define	WINDOW	338
#define	XLABEL	339
#define	YLABEL	340
#define	META	341
#define	OLD	342
#define	ROW	343
#define	ABS	344
#define	ACOS	345
#define	ASIN	346
#define	ATAN	347
#define	ATAN2	348
#define	CONCAT	349
#define	COS	350
#define	DIMEN	351
#define	EXP	352
#define	FFT	353
#define	GAMMA	354
#define	INT	355
#define	LG	356
#define	LN	357
#define	PI	358
#define	RANDOM	359
#define	SIN	360
#define	SQRT	361
#define	SUM	362
#define	TAN	363
#define	POWER_SYMBOL	364
#define	ATOF	365
#define	INDEX	366
#define	LENGTH	367
#define	SPRINTF	368
#define	STRLEN	369
#define	SUBSTR	370
#define	UNARY	371

/* #line 1 "control.y" */

#  include "copyright.h"
#  include "options.h"
#  include <math.h>
#  include <stdio.h>
#  include <ctype.h>
#ifndef INTEGER
#  include "control.h"
#endif
#  include "stack.h"
#  include "vectors.h"
#  include "yaccun.h"
#  include "devices.h"
#  include "sm_declare.h"
#  if defined(_IBMR2)
#     pragma alloca
#  endif

#define bcopy(S1,S2,N) memcpy(S2,S1,N)	/* use memcpy instead */
#define Pi 3.141592653589793238
#ifndef YYIMPURE			/* a bison bug -- yydebug isn't */
   static int yydebug = 0;		/* declared for pure parsers */
#endif
/*
 * And some variables of my own:
 * The Auto Variables get moved into yyparse and made auto when control.y
 * is built (under unix, that is. Under vms, this won't happen).
 */
   static char data_file[CHARMAX], /* name of current data file */
               table_fmt[CHARMAX]; /* format of current TABLE */
   extern char prompt[],	/* system prompt */
               user_name[];	/* name of user of programme */
   extern FILE *logfil;		/* where to log all terminal input */
   static float x_range = 0,	/* Ranges for the x */
		y_range = 0;	/* and y axes */
   static int in_graphics = 0,	/* are graphics active? */
              graph_mode,	/* terminal is set to graph mode */
	      line_1,line_2,	/* line numbers to use in data_file */
              subtable = -1;	/* which sub-table to read */
   extern int abort_plot,	/* abort current plot */
              in_quote,		/* am I in a quoted string? */
   	      sm_interrupt,	/* do you want to interrupt something ? */
   	      noexpand,		/* expand @#$ ? */
	      plength,		/* number of printing chars in prompt */
	      recurse_lvl,	/* how deeply nested are we? */
   	      sm_verbose;	/* produce lots of output */
/*
  This grammar generates 15 Shift/Reduce and 6 Reduce/Reduce conflicts.
  They are (approximately; state numbers may vary):
State 9 contains 2 shift/reduce conflicts.	DELETE . HISTORY/WORD ...
State 25 contains 1 shift/reduce conflicts.	RESTORE . word_or_space
State 26 contains 1 shift/reduce conflicts.	SAVE . word_or_space
State 69 contains 2 shift/reduce conflicts.	DELETE . '!'
State 146 contains 2 reduce/reduce conflicts.   '-' . expr
State 149 contains 1 shift/reduce conflict.	ANGLE expr . '!' ...
State 153 contains 1 shift/reduce conflict.	expr . '!' ...
State 162 contains 1 shift/reduce conflict.	EXPAND expr . '!' ...
State 171 contains 1 shift/reduce conflict.	LEVELS expr . '!' ...
State 207 contains 2 shift/reduce conflicts.	GRID . integer_or_space ...
State 404 contains 2 shift/reduce conflict.	expr . [ IF ... ]
State 418 contains 2 reduce/reduce conflicts.   WORD ( WORD . )
State 500 contains 1 shift/reduce conflict.	plot pexpr pexpr . [ IF ... ]
State 578 contains 1 shift/reduce conflict.	SURFACE INTEGER .
State 593 contains 2 reduce/reduce conflicts.   WORD ( arg_list , WORD . )
 */

#ifndef YYLTYPE
typedef
  struct yyltype
    {
      int timestamp;
      int first_line;
      int first_column;
      int last_line;
      int last_column;
      char *text;
   }
  yyltype;

#define YYLTYPE yyltype
#endif

#define	YYACCEPT	return(0)
#define	YYABORT	return(1)
#define	YYERROR	return(1)
#ifndef YYSTYPE
#define YYSTYPE int
#endif
#include <stdio.h>



#define	YYFINAL		708
#define	YYFLAG		-32768
#define	YYNTBASE	138

#define YYTRANSLATE(x) (yytranslate[x])

Static Const short Far yytranslate[] = {     0,
     2,     2,     2,     2,     2,     2,     2,     2,     2,   130,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,   121,     2,     2,     2,   128,   119,     2,   134,
   135,   126,   124,   131,   125,     2,   127,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,   117,     2,   122,
   120,   123,   116,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
   136,     2,   137,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,   132,   118,   133,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     1,     2,     3,     4,     5,
     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,
    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,
    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,
    36,    37,    38,    39,    40,    41,    42,    43,    44,    45,
    46,    47,    48,    49,    50,    51,    52,    53,    54,    55,
    56,    57,    58,    59,    60,    61,    62,    63,    64,    65,
    66,    67,    68,    69,    70,    71,    72,    73,    74,    75,
    76,    77,    78,    79,    80,    81,    82,    83,    84,    85,
    86,    87,    88,    89,    90,    91,    92,    93,    94,    95,
    96,    97,    98,    99,   100,   101,   102,   103,   104,   105,
   106,   107,   108,   109,   110,   111,   112,   113,   114,   115,
   129
};

Static Const short Far yyrline[] = {     0,
   123,   131,   134,   146,   162,   173,   178,   184,   186,   211,
   217,   222,   236,   238,   239,   240,   245,   247,   249,   251,
   253,   255,   257,   259,   278,   286,   308,   314,   326,   327,
   328,   349,   354,   387,   404,   406,   411,   416,   417,   448,
   450,   452,   462,   485,   491,   497,   499,   501,   503,   505,
   507,   512,   524,   526,   533,   533,   534,   536,   544,   553,
   555,   557,   559,   570,   572,   587,   589,   591,   601,   603,
   605,   647,   660,   667,   687,   696,   708,   714,   719,   721,
   723,   735,   748,   905,   938,  1037,  1039,  1041,  1043,  1062,
  1068,  1076,  1078,  1080,  1082,  1084,  1086,  1088,  1090,  1090,
  1092,  1102,  1121,  1213,  1215,  1233,  1235,  1237,  1274,  1281,
  1291,  1293,  1313,  1315,  1317,  1319,  1321,  1323,  1355,  1357,
  1362,  1388,  1394,  1403,  1418,  1427,  1444,  1473,  1475,  1492,
  1500,  1557,  1600,  1602,  1609,  1611,  1613,  1615,  1617,  1619,
  1621,  1623,  1628,  1633,  1642,  1651,  1653,  1655,  1657,  1659,
  1661,  1663,  1665,  1667,  1669,  1671,  1678,  1680,  1682,  1684,
  1686,  1688,  1690,  1692,  1694,  1696,  1698,  1700,  1702,  1704,
  1706,  1708,  1710,  1712,  1714,  1716,  1718,  1720,  1722,  1724,
  1726,  1728,  1730,  1732,  1734,  1736,  1740,  1742,  1746,  1748,
  1752,  1754,  1758,  1760,  1764,  1766,  1768,  1806,  1809,  1811,
  1830,  1832,  1834,  1836,  1838,  1843,  1845,  1847,  1849,  1851,
  1853,  1855,  1894,  1896,  1904,  1906,  1908,  1910,  1935,  1967,
  1975,  1977,  1979,  1997,  1999,  2019,  2027,  2037,  2039,  2043,
  2045,  2049,  2095,  2103,  2105,  2118,  2131,  2146,  2148,  2150,
  2152,  2164,  2203,  2205,  2209,  2211,  2215,  2226,  2230,  2232,
  2234,  2238,  2240,  2244,  2251,  2255,  2257,  2259,  2263,  2281,
  2283,  2314,  2325,  2354,  2359,  2370,  2375,  2385,  2387,  2392,
  2394,  2412,  2416,  2477,  2503,  2515,  2517,  2521,  2550,  2552,
  2554,  2561,  2567,  2577,  2587,  2589,  2603,  2638,  2650,  2668,
  2670
};

Static Const char Far * Const Far  yytname[] = {     0,
"error","$illegal.","WORD","STRING","FLOAT","INTEGER","ABORT","APROPOS","BREAK","CHDIR",
"DEFINE","DELETE","DO","EDIT","ELSE","FOREACH","HELP","HISTORY","IF","KEY",
"LIST","LOCAL","MACRO","OVERLOAD","PRINT","PROMPT","QUIT","READ","RESTORE","SAVE",
"SET","SNARK","STANDARD","TERMTYPE","VERBOSE","WHILE","WRITE","ANGLE","ASPECT","AXIS",
"BOX","CONNECT","CONTOUR","CTYPE","CURSOR","DATA","DEVICE","DOT","DRAW","DITHER",
"ERASE","ERRORBAR","EXPAND","FORMAT","GRID","HISTOGRAM","IMAGE","LABEL","LEVELS","LIMITS",
"LINES","LOCATION","LTYPE","LWEIGHT","MINMAX","NOTATION","PAGE","POINTS","PTYPE","PUTLABEL",
"RANGE","RELOCATE","RETURN","SHADE","SORT","SPLINE","SURFACE","TABLE","TICKSIZE","USER",
"VIEWPOINT","WHATIS","WINDOW","XLABEL","YLABEL","META","OLD","ROW","ABS","ACOS",
"ASIN","ATAN","ATAN2","CONCAT","COS","DIMEN","EXP","FFT","GAMMA","INT",
"LG","LN","PI","RANDOM","SIN","SQRT","SUM","TAN","POWER_SYMBOL","ATOF",
"INDEX","LENGTH","SPRINTF","STRLEN","SUBSTR","'?'","':'","'|'","'&'","'='",
"'!'","'<'","'>'","'+'","'-'","'*'","'/'","'%'","UNARY","'\\n'",
"','","'{'","'}'","'('","')'","'['","']'","line"
};

Static Const short Far yyr1[] = {     0,
   138,   138,   139,   139,   139,   139,   139,   139,   139,   139,
   139,   139,   139,   140,   139,   139,   139,   139,   139,   139,
   139,   139,   139,   139,   139,   139,   139,   139,   141,   139,
   139,   139,   139,   139,   139,   139,   142,   139,   139,   139,
   139,   139,   139,   139,   139,   139,   139,   139,   139,   139,
   139,   139,   139,   139,   143,   139,   139,   139,   139,   139,
   139,   139,   139,   139,   139,   139,   139,   139,   139,   139,
   139,   139,   139,   139,   139,   139,   139,   139,   139,   139,
   139,   139,   139,   139,   139,   139,   139,   139,   139,   139,
   139,   139,   139,   139,   139,   139,   139,   139,   144,   139,
   139,   139,   139,   139,   139,   139,   139,   139,   139,   139,
   139,   139,   139,   139,   139,   139,   139,   139,   139,   139,
   139,   145,   145,   145,   145,   145,   146,   146,   146,   146,
   146,   146,   146,   146,   146,   146,   146,   146,   146,   146,
   146,   146,   146,   146,   146,   146,   146,   146,   146,   146,
   146,   146,   146,   146,   146,   146,   146,   146,   146,   146,
   146,   146,   146,   146,   146,   146,   146,   146,   146,   146,
   146,   146,   146,   146,   146,   146,   146,   146,   146,   146,
   146,   146,   146,   146,   146,   146,   147,   147,   148,   148,
   149,   149,   150,   150,   151,   151,   151,   152,   152,   152,
   152,   152,   152,   152,   152,   152,   152,   152,   152,   152,
   152,   152,   152,   152,   152,   152,   152,   152,   152,   152,
   152,   152,   152,   152,   152,   152,   152,   153,   153,   154,
   154,   155,   155,   156,   156,   156,   156,   157,   157,   157,
   157,   157,   158,   158,   159,   159,   160,   160,   161,   161,
   161,   162,   162,   163,   163,   164,   164,   164,   165,   166,
   166,   166,   167,   168,   168,   168,   168,   168,   168,   168,
   168,   168,   169,   170,   170,   171,   171,   172,   173,   173,
   173,   173,   173,   173,   173,   173,   173,   173,   173,   174,
   174
};

Static Const short Far yyr2[] = {     0,
     0,     2,     1,     1,     1,     2,     1,     2,     2,     2,
     3,     2,     3,     0,     5,     1,     2,     3,     2,     3,
     3,     4,     2,     2,     3,     2,     6,    10,     0,     3,
     1,     2,     6,     6,     3,     2,     0,     2,     1,     1,
     2,     8,    11,     3,     5,     2,     2,     6,     6,    10,
     2,     3,     1,     3,     0,     3,     5,     2,     4,     3,
     4,     3,     3,     3,     4,     5,     3,     3,     5,     3,
     5,     1,     3,     2,     4,     2,     1,     3,     3,     4,
     4,     3,     3,     4,     4,     2,     1,     2,     7,     3,
     9,     9,     9,     9,     9,     3,     3,     4,     0,     6,
     7,     1,     2,     5,     4,     5,     3,     2,     2,     2,
     4,     5,     1,     5,     7,     7,     9,     1,     3,     2,
     3,     0,     1,     3,     1,     3,     1,     3,     1,     1,
     4,     4,     3,     2,     5,     4,     4,     4,     4,     6,
     4,     3,     4,     6,     8,     4,     3,     3,     3,     3,
     3,     3,     3,     3,     4,     2,     4,     4,     4,     3,
     4,     3,     4,     4,     6,     6,     6,     6,     6,     6,
     6,     6,     4,     4,     4,     4,     1,     1,     4,     4,
     6,     4,     4,     4,     8,     4,     3,     3,     3,     3,
     1,     2,     1,     0,     3,     1,     1,    10,    10,    11,
     1,     3,     5,     1,     3,     2,     2,     1,     3,     5,
     1,     5,     3,     1,     2,     2,     1,     3,     7,     2,
     3,     5,     4,     4,     6,     1,     1,     1,     2,     1,
     0,     1,     2,     0,     2,     2,     2,     2,     2,     4,
     4,     4,     1,     1,     0,     2,     1,     3,     1,     1,
     1,     1,     0,     0,     1,     1,     1,     0,     1,     1,
     5,     4,     0,     2,     2,     3,     1,     1,     2,     3,
     1,     1,     0,     1,     4,     0,     1,     0,     1,     1,
     1,     1,     2,     3,     1,     1,     2,     1,     3,     0,
     1
};

Static Const short Far yydefact[] = {     1,
     0,    31,   118,     5,     7,   113,     0,   278,    16,   278,
    29,   278,    39,    40,     0,    53,    55,     0,     0,   278,
   253,    72,    77,   194,   290,   290,     0,   102,     0,   258,
     0,   253,   258,   258,     0,     0,     0,     0,   258,   258,
     0,   258,   258,     0,     0,   258,     0,   258,     0,   258,
    87,     0,     0,   231,   258,     0,   258,     0,     0,   258,
     4,     3,     2,     0,     9,   258,    23,   228,    19,     0,
    17,     0,   263,     0,    41,   258,     0,   278,     0,   231,
     0,     0,     0,     0,     0,   252,   290,   258,     0,   276,
     0,     0,   193,     0,   291,    86,    88,     0,     0,     0,
     0,   258,   231,     0,     0,     0,   257,   256,   110,     0,
   273,   273,     0,     0,   120,     0,   129,   274,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,   178,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,   258,   234,   256,   234,   258,
     6,   127,   177,   130,   259,     8,     0,    10,    12,    26,
    24,     0,     0,    32,   244,    36,   243,   258,    47,    46,
     0,     0,    51,   247,   258,   258,   258,   232,     0,     0,
    58,     0,   258,    74,     0,   258,    76,   258,   103,     0,
   230,   276,   258,   108,   109,   258,     0,     0,     0,   258,
   201,   249,   204,     0,   208,   258,   211,     0,   231,   250,
   214,   258,   217,   251,     0,   258,   191,     0,   226,   227,
     0,    38,     0,   279,   280,     0,   282,   254,   286,   288,
   258,   281,   285,    13,    20,    21,   229,    18,   258,    30,
   197,   234,   196,     0,     0,     0,   268,     0,   272,   267,
   271,    56,    14,    99,    60,   230,     0,    64,    62,    63,
   253,    70,   276,    82,    79,   274,   277,     0,     0,   258,
    83,     0,    97,   258,   258,    90,   258,   258,     0,    96,
   107,   263,   258,   258,   238,   239,     0,     0,   273,   119,
   121,   122,   258,   258,   258,     0,     0,   258,   258,   258,
   258,   258,   258,   258,   258,   258,   258,   258,   258,   258,
   258,   258,   258,   258,   258,   258,   258,   258,   258,   258,
   258,   156,   258,   134,   258,     0,   258,   258,   258,   258,
   258,     0,     0,   258,   258,   258,   258,   258,   258,   258,
    11,    25,   258,    35,   258,     0,    44,     0,     0,    52,
   233,    54,     0,    68,   258,    73,     0,    78,     0,     0,
   258,   258,     0,    67,     0,   258,     0,   207,   206,   258,
   258,   258,     0,   231,   216,   215,   220,   258,   258,   192,
   258,     0,     0,   283,   255,   287,     0,    22,     0,   258,
   273,     0,     0,   264,   265,     0,   269,   258,     0,    61,
    59,    65,     0,     0,    85,    80,    81,    84,   260,     0,
    98,     0,     0,     0,     0,     0,     0,     0,     0,   189,
   190,     0,   129,     0,   125,     0,     0,     0,     0,     0,
   142,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,   187,   237,   235,   236,
   188,   133,   128,   151,     0,   258,   154,   258,   153,   258,
   258,   258,   162,   258,   160,   147,   148,   149,   150,   152,
   258,   258,     0,     0,   248,     0,   258,    75,     0,   105,
   258,   111,     0,     0,   258,   202,   205,   258,   209,   258,
   213,   258,   221,   258,     0,   218,   284,   289,   258,   195,
     0,   273,   266,   270,    15,   258,    66,    71,     0,   258,
     0,   258,   258,   258,     0,   242,   240,   241,   112,   258,
   131,   132,   183,   258,   275,   143,   258,   258,   258,   258,
   136,   137,   138,   139,   258,   141,   146,   258,   173,   175,
   176,   179,   180,   182,   186,   164,   258,   174,   258,   184,
   258,   258,   159,   158,   155,   157,   163,   161,     0,   258,
    45,     0,    57,    69,   104,   106,     0,   114,     0,   258,
     0,     0,     0,     0,     0,   224,   223,     0,   245,    34,
     0,   100,   258,   245,   258,     0,     0,     0,     0,     0,
   258,   129,   126,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,   135,    27,    48,    49,     0,
     0,    33,     0,     0,   203,   210,   212,   222,     0,   258,
   258,     0,     0,     0,   262,   101,     0,     0,     0,     0,
     0,    89,   258,   144,   166,   167,   171,   169,   170,   168,
   140,   165,   172,   181,   258,   258,   116,   115,     0,     0,
     0,   225,     0,   246,   273,     0,    42,   261,   258,   258,
   258,   258,   258,     0,     0,   258,     0,     0,     0,     0,
   219,     0,   273,    91,    95,    93,    94,    92,   145,   185,
   258,   117,     0,     0,     0,    28,     0,    50,     0,     0,
     0,    43,   198,     0,   199,   200,     0,     0
};

Static Const short Far yydefgoto[] = {     1,
    63,   398,    73,    64,    77,   399,   424,   155,   152,   232,
   221,    94,   244,   222,   191,   192,   176,   323,   153,   459,
   632,   178,   223,    87,   386,   110,   410,   411,   240,   252,
   287,   154,   268,    66,   234,    96
};

Static Const short Far yypact[] = {-32768,
  2195,-32768,-32768,-32768,-32768,-32768,    39,-32768,    75,-32768,
-32768,-32768,-32768,   -69,   -71,-32768,-32768,    55,   105,-32768,
   -37,-32768,-32768,   251,    96,    96,   223,-32768,    97,   216,
   -64,    88,  1954,  1954,    54,   115,    42,   127,  1954,   160,
    24,  1954,     0,   125,   138,   216,   147,   216,    19,   216,
-32768,   -52,   152,    71,   216,    77,   216,    71,   129,   216,
-32768,-32768,-32768,   551,-32768,   157,-32768,-32768,    82,   164,
    71,    58,-32768,    40,-32768,  1954,   387,-32768,   192,    79,
   194,   203,   205,   217,    71,-32768,    96,    13,   222,    36,
   227,   229,-32768,    34,-32768,-32768,-32768,   123,   235,   -62,
   112,   216,    71,   118,   121,   124,-32768,-32768,-32768,   117,
-32768,-32768,   131,   258,-32768,   263,   -42,   136,   137,   142,
   143,   144,    -7,   149,   153,   158,   165,   169,   170,   172,
   174,   175,   176,   179,-32768,   181,   186,   188,   191,   196,
   197,   200,   210,   214,   233,  1954,-32768,  1954,-32768,  1954,
  2698,-32768,-32768,-32768,  2698,-32768,   269,-32768,-32768,-32768,
-32768,   348,   350,  2698,-32768,-32768,-32768,    13,   295,-32768,
    61,   351,  2698,-32768,  1954,     0,   216,-32768,   364,   367,
-32768,   371,   216,-32768,   369,  1954,-32768,   216,-32768,   373,
-32768,    36,   216,-32768,-32768,   216,    71,   376,     2,   216,
   386,-32768,-32768,    26,-32768,   363,-32768,     2,    71,-32768,
-32768,   211,-32768,-32768,   388,   365,   339,    71,-32768,-32768,
   390,-32768,     2,-32768,-32768,   394,-32768,   -64,-32768,-32768,
  1954,-32768,-32768,-32768,-32768,    71,-32768,-32768,  1954,-32768,
-32768,-32768,-32768,   271,   270,    31,-32768,    62,-32768,-32768,
-32768,-32768,-32768,-32768,-32768,    71,   -64,-32768,-32768,-32768,
   -63,-32768,    36,-32768,-32768,-32768,-32768,   -52,   403,    13,
-32768,   -52,-32768,  1954,  1954,-32768,  1954,   818,   405,-32768,
-32768,-32768,  1954,  1954,-32768,-32768,   288,   279,-32768,-32768,
-32768,   694,  1954,  1954,  1954,   410,     8,  1954,  1954,   932,
  1954,  1954,  1954,  1954,  1954,  1954,  1954,  1954,  1954,  1954,
  1954,  1954,  1954,  1954,  1954,  1954,  1954,  1954,  1954,  1954,
  1954,   306,    94,   306,    98,   601,  1954,  1954,  1954,  1046,
  1159,   296,   297,  1272,  1385,  1954,  1954,  1954,  1954,  1954,
-32768,-32768,   216,-32768,   216,   432,-32768,   311,  1072,-32768,
-32768,-32768,   437,-32768,   216,-32768,  1108,-32768,   441,   443,
   216,   216,    71,-32768,     2,   216,   442,-32768,-32768,  1954,
   216,   216,     2,    71,-32768,-32768,-32768,   216,   216,-32768,
   216,     2,     2,   444,-32768,-32768,  1183,-32768,   320,    86,
-32768,   322,   452,-32768,-32768,   453,-32768,   157,   337,-32768,
-32768,-32768,   457,   -52,-32768,-32768,-32768,-32768,   305,   333,
-32768,   530,  2458,   336,  2478,   341,   342,  1218,  1296,-32768,
-32768,   335,   114,   -56,  2698,   718,  1331,   340,   356,   368,
-32768,  2658,  2498,   343,  2518,  1409,  1444,  1524,  1561,  2538,
  1638,  1675,  2558,  1752,  1789,  1866,   370,  1903,  1978,  2013,
  2183,  2578,  2218,  2598,  2238,  2618,-32768,-32768,-32768,-32768,
-32768,-32768,   354,-32768,  2678,  1954,   550,  1954,   756,  1954,
  1954,  1954,   313,  1954,   313,   219,   219,   306,   306,   306,
   216,   216,   482,   480,-32768,   492,   216,-32768,   497,-32768,
   216,-32768,    48,   501,     0,   500,  2718,   216,-32768,  1954,
-32768,   216,-32768,   216,     2,   488,-32768,-32768,  1954,-32768,
   380,-32768,-32768,-32768,-32768,  1954,-32768,-32768,   375,  1954,
   395,  1954,  1498,  1612,   420,-32768,-32768,-32768,-32768,  2067,
-32768,-32768,-32768,  1954,-32768,-32768,  1954,  1954,  1726,  1840,
-32768,-32768,-32768,-32768,  1954,-32768,-32768,  1954,-32768,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,  1954,-32768,  1954,-32768,
  1954,  1954,   550,   756,   313,   313,   313,   313,    71,   216,
-32768,   379,-32768,-32768,-32768,-32768,    71,   413,   539,   216,
     2,   537,   409,   262,   415,   556,-32768,   427,   433,-32768,
   430,-32768,  1954,   433,  1954,  2258,   429,   844,   434,   881,
    13,   224,  2698,   -21,  2278,  2298,   436,   958,   438,   995,
  2318,  2338,  2358,  2378,  2638,  2698,-32768,-32768,   295,    71,
    71,-32768,   561,   110,-32768,-32768,-32768,-32768,   566,  1954,
  1954,   445,     5,  2398,-32768,  2718,   450,   454,   456,   458,
   459,-32768,  1954,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,-32768,-32768,  1954,   216,   464,-32768,   576,   577,
   578,-32768,  2418,-32768,-32768,   455,-32768,-32768,  1954,  1954,
  1954,  1954,  1954,   451,  2438,   216,    71,   579,   583,   590,
-32768,   465,-32768,  2718,  2718,  2718,  2718,  2718,-32768,-32768,
   216,-32768,   591,   595,   598,-32768,   475,-32768,   604,   607,
   609,-32768,-32768,   610,-32768,-32768,   620,-32768
};

Static Const short Far yypgoto[] = {-32768,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,   218,   -39,   -13,
-32768,-32768,-32768,-32768,    -9,   -57,   446,  -116,   -29,   -36,
    32,  -184,-32768,   -25,-32768,-32768,   -26,   113,   349,-32768,
  -103,   -88,  -151,   285,   232,    18
};


#define	YYLAST		2846


Static Const short Far yytable[] = {    71,
   109,   267,   174,   168,   174,   272,   116,   156,   288,   187,
   167,   430,   189,   177,   365,   165,   181,   113,   183,   666,
   188,   184,   257,   373,   185,   193,   169,   196,   368,   233,
   199,   369,   325,   393,   243,   170,   167,   266,   383,   266,
   360,    65,   241,    97,   160,   281,   195,   161,   197,   245,
   120,   264,   120,    68,   271,    75,   157,   111,   167,   236,
    86,   238,    76,   346,   396,    78,   402,   112,   171,   147,
   256,   277,   280,   278,   530,   262,    68,    67,   531,   149,
    68,   104,    68,   194,    68,    79,    86,    68,   165,   266,
   255,   292,    69,   293,   104,   105,   165,   266,    95,   103,
   165,   266,   120,   267,   263,   114,   106,    80,   105,   643,
   120,   404,   660,   644,   120,   661,    81,   159,    82,   106,
   115,   285,   286,   107,   108,   390,   299,   162,   300,   163,
   179,   344,    83,   175,   667,   175,   107,   108,   167,   345,
   147,    84,   431,   180,   273,   370,   177,   351,   394,   182,
   149,   374,   186,   355,   190,   147,   198,   172,   358,   165,
   395,   147,   165,   361,   577,   149,   362,   104,   224,   237,
   366,   149,    70,   242,   267,   104,   372,   239,   225,   104,
   494,   105,   376,   158,   226,   422,   379,   363,   500,   105,
   347,   397,   106,   105,   254,    70,   258,   505,   506,    70,
   106,    70,   235,    70,   106,   259,    70,   260,   381,   107,
   108,    86,   389,   227,   385,   458,   457,   107,   108,   261,
   510,   107,   108,   458,   265,    98,   388,   458,   405,   269,
   461,   270,   408,   407,   460,   403,   460,   276,   104,    99,
   167,   104,   274,   401,  -123,   279,   400,   292,  -123,   293,
   151,   282,   105,    88,   283,   105,   164,   284,   275,   173,
   290,   375,   289,   106,    89,   291,   106,   627,   428,   294,
   295,   341,   228,   229,   230,   296,   297,   298,   111,   100,
   107,   108,   301,   107,   108,   447,   302,   511,   112,   166,
   231,   303,   104,   167,    72,   167,    74,   104,   304,  -258,
  -258,   460,   305,   306,    85,   307,   105,   308,   309,   310,
   581,   105,   311,   481,   312,   482,   501,   106,   101,   313,
   587,   314,   106,   519,   315,   487,   102,   328,    90,   316,
   317,   491,   492,   318,   107,   108,   495,    91,    92,   107,
   108,   498,   499,   319,   338,   339,   340,   320,   502,   503,
   342,   504,   343,   493,  -124,   327,   348,   292,  -124,   293,
   167,   233,   253,   322,   518,   324,   321,   326,   167,   352,
   328,    93,   353,   354,   356,   359,   104,   329,   364,   330,
   331,   332,   333,   334,   335,   336,   337,   338,   339,   340,
   105,   367,   349,   377,   380,   382,   624,   246,   327,   384,
   247,   106,   391,   357,   392,   406,   327,   416,   591,   248,
   420,   421,   429,   328,   328,   470,   471,   249,   107,   108,
   329,   328,   330,   331,   332,   333,   334,   335,   336,   337,
   338,   339,   340,   250,   483,  -259,   336,   337,   338,   339,
   340,   484,   486,   489,   104,   490,   104,   496,   387,   507,
   509,   569,   570,   512,   513,   514,   516,   574,   105,   517,
   105,   576,   328,   520,   251,   580,   523,   529,   583,   106,
   534,   106,   585,   539,   586,   525,   526,   336,   337,   338,
   339,   340,   589,   578,   571,   572,   107,   108,   107,   108,
   535,   409,   412,   594,   413,   415,   371,   573,   378,   575,
   418,   419,   536,   579,   552,   582,   588,   604,   593,   425,
   426,   427,   590,   619,   595,   432,   433,   435,   436,   437,
   438,   439,   440,   441,   442,   443,   444,   445,   446,   621,
   448,   449,   450,   451,   452,   453,   454,   455,   456,   601,
   618,   622,   625,   626,   463,   464,   465,   467,   469,   628,
   623,   473,   475,   476,   477,   478,   479,   480,   629,   617,
   630,   682,   633,   631,   642,   638,   659,   620,   662,   669,
   640,   167,   647,   670,   649,   671,   665,   672,   673,   697,
   677,   678,   679,   680,   693,   689,   683,   497,   694,   656,
   200,   201,   202,   203,   204,   695,   699,   696,   205,   206,
   700,   207,   208,   701,   664,   209,   210,   702,   211,   703,
   657,   658,   704,   212,   705,   706,   674,   213,   214,   708,
   215,   350,   216,   327,   217,   635,   676,   218,   592,   515,
   417,     0,     0,     0,   219,   220,     0,     0,   328,     0,
     0,     0,     0,   327,     0,   329,   691,   330,   331,   332,
   333,   334,   335,   336,   337,   338,   339,   340,   328,     0,
     0,   698,     0,     0,     0,     0,   521,   692,   331,   332,
   333,   334,   335,   336,   337,   338,   339,   340,     0,     0,
     0,     0,     0,   563,     0,   564,     0,   565,   566,   567,
     0,   568,     0,     0,   327,     0,   423,   118,  -258,  -258,
     0,     0,     0,     0,     0,     0,   119,     0,     0,   328,
   120,     0,     0,     0,     0,     0,   329,   584,   330,   331,
   332,   333,   334,   335,   336,   337,   338,   339,   340,     0,
     0,     0,     0,   409,     0,   462,     0,   121,     0,   596,
   598,   600,     0,     0,     0,     0,     0,   603,     0,   122,
   123,     0,     0,     0,   605,   606,   608,   610,     0,     0,
     0,     0,   611,     0,     0,   612,     0,     0,     0,     0,
     0,     0,     0,     0,   613,   104,   614,     0,   615,   616,
     0,     0,   124,   125,   126,   127,   128,     0,   129,   105,
   130,     0,   131,   132,   133,   134,   135,   136,   137,   138,
   106,   139,     0,   140,   141,   142,   143,   144,   145,     0,
   634,   327,   636,     0,   146,   147,     0,   107,   148,     0,
   117,   118,     0,     0,     0,   149,   328,   150,     0,     0,
   119,     0,     0,   329,   120,   330,   331,   332,   333,   334,
   335,   336,   337,   338,   339,   340,     0,   663,     0,   327,
     0,     0,     0,     0,   532,     0,     0,     0,     0,     0,
     0,   121,     0,     0,   328,     0,     0,     0,     0,     0,
     0,     0,   675,   122,   123,   332,   333,   334,   335,   336,
   337,   338,   339,   340,     0,     0,   684,   685,   686,   687,
   688,     0,     0,     0,     0,     0,     0,     0,     0,   104,
     0,     0,     0,     0,     0,     0,   124,   125,   126,   127,
   128,     0,   129,   105,   130,     0,   131,   132,   133,   134,
   135,   136,   137,   138,   106,   139,     0,   140,   141,   142,
   143,   144,   145,     0,   117,   118,     0,   327,   146,   147,
     0,   107,   148,   414,   119,     0,     0,     0,   120,   149,
     0,   150,   328,     0,     0,     0,     0,     0,     0,   329,
     0,   330,   331,   332,   333,   334,   335,   336,   337,   338,
   339,   340,     0,     0,   327,   121,     0,     0,     0,     0,
   639,     0,     0,     0,     0,     0,     0,   122,   123,   328,
     0,     0,     0,     0,     0,     0,   329,     0,   330,   331,
   332,   333,   334,   335,   336,   337,   338,   339,   340,     0,
     0,     0,     0,   104,     0,     0,     0,   641,     0,     0,
   124,   125,   126,   127,   128,     0,   129,   105,   130,     0,
   131,   132,   133,   134,   135,   136,   137,   138,   106,   139,
     0,   140,   141,   142,   143,   144,   145,     0,   117,   118,
     0,   327,   146,   147,     0,   107,   148,   434,   119,     0,
     0,     0,   120,   149,     0,   150,   328,     0,     0,     0,
     0,     0,     0,   329,     0,   330,   331,   332,   333,   334,
   335,   336,   337,   338,   339,   340,     0,     0,   327,   121,
     0,     0,     0,     0,   648,     0,     0,     0,     0,     0,
     0,   122,   123,   328,     0,     0,     0,     0,     0,     0,
   329,     0,   330,   331,   332,   333,   334,   335,   336,   337,
   338,   339,   340,     0,     0,     0,     0,   104,     0,     0,
     0,   650,     0,     0,   124,   125,   126,   127,   128,     0,
   129,   105,   130,     0,   131,   132,   133,   134,   135,   136,
   137,   138,   106,   139,     0,   140,   141,   142,   143,   144,
   145,   117,   118,   466,     0,   327,   146,   147,     0,   107,
   148,   119,     0,     0,     0,   120,     0,   149,     0,   150,
   328,     0,     0,     0,     0,     0,     0,   329,     0,   330,
   331,   332,   333,   334,   335,   336,   337,   338,   339,   340,
     0,   327,   121,     0,     0,     0,   485,     0,     0,     0,
     0,     0,     0,     0,   122,   123,   328,     0,     0,     0,
     0,     0,     0,   329,     0,   330,   331,   332,   333,   334,
   335,   336,   337,   338,   339,   340,     0,     0,     0,     0,
   104,     0,   488,     0,     0,     0,     0,   124,   125,   126,
   127,   128,     0,   129,   105,   130,     0,   131,   132,   133,
   134,   135,   136,   137,   138,   106,   139,     0,   140,   141,
   142,   143,   144,   145,   117,   118,   327,   468,     0,   146,
   147,     0,   107,   148,   119,     0,     0,     0,   120,     0,
   149,   328,   150,     0,     0,     0,     0,     0,   329,     0,
   330,   331,   332,   333,   334,   335,   336,   337,   338,   339,
   340,   327,     0,     0,     0,   121,     0,   508,     0,     0,
     0,     0,     0,     0,     0,     0,   328,   122,   123,     0,
     0,     0,     0,   329,     0,   330,   331,   332,   333,   334,
   335,   336,   337,   338,   339,   340,     0,     0,     0,     0,
     0,     0,   527,   104,     0,     0,     0,     0,     0,     0,
   124,   125,   126,   127,   128,     0,   129,   105,   130,     0,
   131,   132,   133,   134,   135,   136,   137,   138,   106,   139,
     0,   140,   141,   142,   143,   144,   145,   117,   118,   327,
     0,   472,   146,   147,     0,   107,   148,   119,     0,     0,
     0,   120,     0,   149,   328,   150,     0,     0,     0,     0,
     0,   329,     0,   330,   331,   332,   333,   334,   335,   336,
   337,   338,   339,   340,   327,     0,     0,     0,   121,     0,
   528,     0,     0,     0,     0,     0,     0,     0,     0,   328,
   122,   123,     0,     0,     0,     0,   329,     0,   330,   331,
   332,   333,   334,   335,   336,   337,   338,   339,   340,     0,
     0,     0,     0,     0,     0,   533,   104,     0,     0,     0,
     0,     0,     0,   124,   125,   126,   127,   128,     0,   129,
   105,   130,     0,   131,   132,   133,   134,   135,   136,   137,
   138,   106,   139,     0,   140,   141,   142,   143,   144,   145,
   117,   118,   327,     0,   474,   146,   147,     0,   107,   148,
   119,     0,     0,     0,   120,     0,   149,   328,   150,     0,
     0,     0,     0,     0,   329,     0,   330,   331,   332,   333,
   334,   335,   336,   337,   338,   339,   340,   327,     0,     0,
     0,   121,     0,   541,     0,     0,     0,     0,     0,     0,
     0,     0,   328,   122,   123,     0,     0,     0,     0,   329,
     0,   330,   331,   332,   333,   334,   335,   336,   337,   338,
   339,   340,     0,     0,     0,     0,     0,     0,   542,   104,
     0,     0,     0,     0,     0,     0,   124,   125,   126,   127,
   128,     0,   129,   105,   130,     0,   131,   132,   133,   134,
   135,   136,   137,   138,   106,   139,     0,   140,   141,   142,
   143,   144,   145,     0,   117,   118,     0,   327,   146,   147,
     0,   107,   148,   597,   119,     0,     0,     0,   120,   149,
     0,   150,   328,     0,     0,     0,     0,     0,     0,   329,
     0,   330,   331,   332,   333,   334,   335,   336,   337,   338,
   339,   340,     0,     0,   327,   121,     0,     0,   543,     0,
     0,     0,     0,     0,     0,     0,     0,   122,   123,   328,
     0,     0,     0,     0,     0,     0,   329,     0,   330,   331,
   332,   333,   334,   335,   336,   337,   338,   339,   340,     0,
     0,     0,     0,   104,     0,   544,     0,     0,     0,     0,
   124,   125,   126,   127,   128,     0,   129,   105,   130,     0,
   131,   132,   133,   134,   135,   136,   137,   138,   106,   139,
     0,   140,   141,   142,   143,   144,   145,     0,   117,   118,
     0,   327,   146,   147,     0,   107,   148,   599,   119,     0,
     0,     0,   120,   149,     0,   150,   328,     0,     0,     0,
     0,     0,     0,   329,     0,   330,   331,   332,   333,   334,
   335,   336,   337,   338,   339,   340,     0,     0,   327,   121,
     0,     0,   546,     0,     0,     0,     0,     0,     0,     0,
     0,   122,   123,   328,     0,     0,     0,     0,     0,     0,
   329,     0,   330,   331,   332,   333,   334,   335,   336,   337,
   338,   339,   340,     0,     0,     0,     0,   104,     0,   547,
     0,     0,     0,     0,   124,   125,   126,   127,   128,     0,
   129,   105,   130,     0,   131,   132,   133,   134,   135,   136,
   137,   138,   106,   139,     0,   140,   141,   142,   143,   144,
   145,     0,   117,   118,     0,   327,   146,   147,     0,   107,
   148,   607,   119,     0,     0,     0,   120,   149,     0,   150,
   328,     0,     0,     0,     0,     0,     0,   329,     0,   330,
   331,   332,   333,   334,   335,   336,   337,   338,   339,   340,
     0,     0,   327,   121,     0,     0,   549,     0,     0,     0,
     0,     0,     0,     0,     0,   122,   123,   328,     0,     0,
     0,     0,     0,     0,   329,     0,   330,   331,   332,   333,
   334,   335,   336,   337,   338,   339,   340,     0,     0,     0,
     0,   104,     0,   550,     0,     0,     0,     0,   124,   125,
   126,   127,   128,     0,   129,   105,   130,     0,   131,   132,
   133,   134,   135,   136,   137,   138,   106,   139,     0,   140,
   141,   142,   143,   144,   145,     0,   117,   118,     0,   327,
   146,   147,     0,   107,   148,   609,   119,     0,     0,     0,
   120,   149,     0,   150,   328,     0,     0,     0,     0,     0,
     0,   329,     0,   330,   331,   332,   333,   334,   335,   336,
   337,   338,   339,   340,     0,     0,   327,   121,     0,     0,
   551,     0,     0,     0,     0,     0,     0,     0,     0,   122,
   123,   328,     0,     0,     0,     0,     0,     0,   329,     0,
   330,   331,   332,   333,   334,   335,   336,   337,   338,   339,
   340,     0,     0,     0,     0,   104,     0,   553,     0,     0,
     0,     0,   124,   125,   126,   127,   128,     0,   129,   105,
   130,     0,   131,   132,   133,   134,   135,   136,   137,   138,
   106,   139,     0,   140,   141,   142,   143,   144,   145,   602,
   118,   327,     0,     0,   146,   147,     0,   107,   148,   119,
     0,     0,     0,   120,     0,   149,   328,   150,     0,     0,
     0,     0,     0,   329,     0,   330,   331,   332,   333,   334,
   335,   336,   337,   338,   339,   340,   327,     0,     0,     0,
   121,     0,   554,     0,     0,     0,     0,     0,     0,     0,
     0,   328,   122,   123,     0,     0,     0,     0,   329,     0,
   330,   331,   332,   333,   334,   335,   336,   337,   338,   339,
   340,     0,     0,     0,     0,     0,     0,   555,   104,     0,
     0,     0,     0,     0,     0,   124,   125,   126,   127,   128,
     0,   129,   105,   130,     0,   131,   132,   133,   134,   135,
   136,   137,   138,   106,   139,     0,   140,   141,   142,   143,
   144,   145,     0,     0,     0,     0,     0,   146,   147,     0,
   107,   148,     0,     0,   707,     2,     0,     3,   149,     0,
   150,     4,     5,     6,     7,     8,     9,    10,    11,     0,
    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,
    22,    23,    24,    25,    26,    27,    28,     0,    29,    30,
    31,    32,    33,    34,   -37,   -37,   -37,   -37,   -37,    35,
    36,    37,   -37,   -37,    38,   -37,   -37,    39,    40,   -37,
   -37,    41,   -37,    42,    43,    44,    45,   -37,    46,    47,
    48,   -37,   -37,    49,   -37,    50,   -37,    51,   -37,    52,
    53,   -37,    54,    55,    56,    57,   327,    58,   -37,   -37,
    59,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,   328,    60,     0,     0,     0,     0,     0,   329,     0,
   330,   331,   332,   333,   334,   335,   336,   337,   338,   339,
   340,   327,     0,     0,     0,    61,     0,   556,     0,     0,
     0,     0,     0,     0,    62,     0,   328,     0,     0,     0,
     0,   327,     0,   329,     0,   330,   331,   332,   333,   334,
   335,   336,   337,   338,   339,   340,   328,     0,     0,     0,
     0,   327,   558,   329,     0,   330,   331,   332,   333,   334,
   335,   336,   337,   338,   339,   340,   328,     0,     0,     0,
     0,   327,   560,   329,     0,   330,   331,   332,   333,   334,
   335,   336,   337,   338,   339,   340,   328,     0,     0,     0,
     0,   327,   637,   329,     0,   330,   331,   332,   333,   334,
   335,   336,   337,   338,   339,   340,   328,     0,     0,     0,
     0,   327,   645,   329,     0,   330,   331,   332,   333,   334,
   335,   336,   337,   338,   339,   340,   328,     0,     0,     0,
     0,   327,   646,   329,     0,   330,   331,   332,   333,   334,
   335,   336,   337,   338,   339,   340,   328,     0,     0,     0,
     0,   327,   651,   329,     0,   330,   331,   332,   333,   334,
   335,   336,   337,   338,   339,   340,   328,     0,     0,     0,
     0,   327,   652,   329,     0,   330,   331,   332,   333,   334,
   335,   336,   337,   338,   339,   340,   328,     0,     0,     0,
     0,   327,   653,   329,     0,   330,   331,   332,   333,   334,
   335,   336,   337,   338,   339,   340,   328,     0,     0,     0,
     0,   327,   654,   329,     0,   330,   331,   332,   333,   334,
   335,   336,   337,   338,   339,   340,   328,     0,     0,     0,
     0,   327,   668,   329,     0,   330,   331,   332,   333,   334,
   335,   336,   337,   338,   339,   340,   328,     0,     0,     0,
     0,   327,   681,   329,     0,   330,   331,   332,   333,   334,
   335,   336,   337,   338,   339,   340,   328,     0,     0,     0,
     0,   327,   690,   329,     0,   330,   331,   332,   333,   334,
   335,   336,   337,   338,   339,   340,   328,     0,   522,     0,
     0,   327,     0,   329,     0,   330,   331,   332,   333,   334,
   335,   336,   337,   338,   339,   340,   328,     0,   524,     0,
     0,   327,     0,   329,     0,   330,   331,   332,   333,   334,
   335,   336,   337,   338,   339,   340,   328,     0,   538,     0,
     0,   327,     0,   329,     0,   330,   331,   332,   333,   334,
   335,   336,   337,   338,   339,   340,   328,     0,   540,     0,
     0,   327,     0,   329,     0,   330,   331,   332,   333,   334,
   335,   336,   337,   338,   339,   340,   328,     0,   545,     0,
     0,   327,     0,   329,     0,   330,   331,   332,   333,   334,
   335,   336,   337,   338,   339,   340,   328,     0,   548,     0,
     0,   327,     0,   329,     0,   330,   331,   332,   333,   334,
   335,   336,   337,   338,   339,   340,   328,     0,   557,     0,
     0,   327,     0,   329,     0,   330,   331,   332,   333,   334,
   335,   336,   337,   338,   339,   340,   328,     0,   559,     0,
     0,   327,     0,   329,     0,   330,   331,   332,   333,   334,
   335,   336,   337,   338,   339,   340,   328,     0,   561,     0,
     0,   327,     0,   329,     0,   330,   331,   332,   333,   334,
   335,   336,   337,   338,   339,   340,   328,     0,   655,     0,
     0,   327,     0,   329,   537,   330,   331,   332,   333,   334,
   335,   336,   337,   338,   339,   340,   328,     0,     0,     0,
     0,   327,     0,   329,   562,   330,   331,   332,   333,   334,
   335,   336,   337,   338,   339,   340,   328,     0,     0,     0,
     0,   327,     0,   329,     0,   330,   331,   332,   333,   334,
   335,   336,   337,   338,   339,   340,   328,     0,     0,     0,
     0,     0,     0,   329,     0,   330,   331,   332,     0,   334,
   335,   336,   337,   338,   339,   340
};

Static Const short Far yycheck[] = {     9,
    30,    90,     3,    40,     3,    94,    32,    34,   112,    49,
    40,     4,    52,    43,   199,     3,    46,    31,    48,    15,
    50,     3,    80,   208,     6,    55,     3,    57,     3,    66,
    60,     6,   149,     3,    74,    12,    66,     4,   223,     4,
   192,     3,     3,    26,     3,   103,    56,     6,    58,    76,
    17,    88,    17,     6,    94,   125,     3,   122,    88,    69,
   124,    71,   134,     3,     3,    11,   130,   132,    45,   122,
    80,   134,   102,   136,   131,    85,     6,     3,   135,   132,
     6,    82,     6,     7,     6,    31,   124,     6,     3,     4,
    12,   134,    18,   136,    82,    96,     3,     4,     3,     3,
     3,     4,    17,   192,    87,    18,   107,     3,    96,   131,
    17,   263,     3,   135,    17,     6,    12,     3,    14,   107,
    33,     5,     6,   124,   125,   242,   134,    86,   136,     3,
     6,   168,    28,   134,   130,   134,   124,   125,   168,   169,
   122,    37,   135,     6,    22,   120,   176,   177,   118,     3,
   132,   209,   134,   183,     3,   122,    28,   134,   188,     3,
   130,   122,     3,   193,   117,   132,   196,    82,    12,     6,
   200,   132,   125,   134,   263,    82,   206,   120,    22,    82,
   365,    96,   212,   130,    28,   289,   216,   197,   373,    96,
   130,   130,   107,    96,     3,   125,     3,   382,   383,   125,
   107,   125,   121,   125,   107,     3,   125,     3,   218,   124,
   125,   124,   239,    57,   228,   130,   123,   124,   125,     3,
   135,   124,   125,   130,     3,     3,   236,   130,   268,     3,
   133,     3,   272,   270,   323,   261,   325,     3,    82,    17,
   270,    82,   120,   257,   131,   134,   256,   134,   135,   136,
    33,   134,    96,     3,   134,    96,    39,   134,   136,    42,
     3,    51,   132,   107,    14,     3,   107,     6,   295,   134,
   134,     3,   116,   117,   118,   134,   134,   134,   122,    57,
   124,   125,   134,   124,   125,   312,   134,   391,   132,   130,
   134,   134,    82,   323,    10,   325,    12,    82,   134,     5,
     6,   390,   134,   134,    20,   134,    96,   134,   134,   134,
   495,    96,   134,   343,   134,   345,   374,   107,    96,   134,
   505,   134,   107,    19,   134,   355,   104,   109,    78,   134,
   134,   361,   362,   134,   124,   125,   366,    87,    88,   124,
   125,   371,   372,   134,   126,   127,   128,   134,   378,   379,
     3,   381,     3,   363,   131,    94,     6,   134,   135,   136,
   390,   398,    78,   146,   404,   148,   134,   150,   398,     6,
   109,   121,     6,     3,     6,     3,    82,   116,     3,   118,
   119,   120,   121,   122,   123,   124,   125,   126,   127,   128,
    96,     6,   175,     6,    56,     6,   581,    11,    94,     6,
    14,   107,   132,   186,   135,     3,    94,     3,   512,    23,
   123,   133,     3,   109,   109,   120,   120,    31,   124,   125,
   116,   109,   118,   119,   120,   121,   122,   123,   124,   125,
   126,   127,   128,    47,     3,   131,   124,   125,   126,   127,
   128,   131,     6,     3,    82,     3,    82,     6,   231,     6,
   131,   481,   482,   132,     3,     3,   120,   487,    96,     3,
    96,   491,   109,   131,    78,   495,   131,   133,   498,   107,
   131,   107,   502,   131,   504,   135,   135,   124,   125,   126,
   127,   128,   509,   493,     3,     6,   124,   125,   124,   125,
   135,   274,   275,   520,   277,   278,   134,     6,   134,     3,
   283,   284,   135,     3,   135,     6,    19,   534,   134,   292,
   293,   294,   133,   135,   120,   298,   299,   300,   301,   302,
   303,   304,   305,   306,   307,   308,   309,   310,   311,   117,
   313,   314,   315,   316,   317,   318,   319,   320,   321,   120,
   570,     3,     6,   135,   327,   328,   329,   330,   331,   135,
   580,   334,   335,   336,   337,   338,   339,   340,     3,   569,
   134,   665,   133,   131,   601,   137,     6,   577,     3,   120,
   137,   601,   137,   120,   137,   120,   132,   120,   120,   683,
   117,     6,     6,     6,     6,   135,   132,   370,     6,   619,
    40,    41,    42,    43,    44,     6,     6,   133,    48,    49,
     6,    51,    52,     6,   631,    55,    56,   133,    58,     6,
   620,   621,     6,    63,     6,     6,   643,    67,    68,     0,
    70,   176,    72,    94,    74,   594,   656,    77,   516,   398,
   282,    -1,    -1,    -1,    84,    85,    -1,    -1,   109,    -1,
    -1,    -1,    -1,    94,    -1,   116,   676,   118,   119,   120,
   121,   122,   123,   124,   125,   126,   127,   128,   109,    -1,
    -1,   691,    -1,    -1,    -1,    -1,   137,   677,   119,   120,
   121,   122,   123,   124,   125,   126,   127,   128,    -1,    -1,
    -1,    -1,    -1,   466,    -1,   468,    -1,   470,   471,   472,
    -1,   474,    -1,    -1,    94,    -1,     3,     4,     5,     6,
    -1,    -1,    -1,    -1,    -1,    -1,    13,    -1,    -1,   109,
    17,    -1,    -1,    -1,    -1,    -1,   116,   500,   118,   119,
   120,   121,   122,   123,   124,   125,   126,   127,   128,    -1,
    -1,    -1,    -1,   516,    -1,   135,    -1,    44,    -1,   522,
   523,   524,    -1,    -1,    -1,    -1,    -1,   530,    -1,    56,
    57,    -1,    -1,    -1,   537,   538,   539,   540,    -1,    -1,
    -1,    -1,   545,    -1,    -1,   548,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,   557,    82,   559,    -1,   561,   562,
    -1,    -1,    89,    90,    91,    92,    93,    -1,    95,    96,
    97,    -1,    99,   100,   101,   102,   103,   104,   105,   106,
   107,   108,    -1,   110,   111,   112,   113,   114,   115,    -1,
   593,    94,   595,    -1,   121,   122,    -1,   124,   125,    -1,
     3,     4,    -1,    -1,    -1,   132,   109,   134,    -1,    -1,
    13,    -1,    -1,   116,    17,   118,   119,   120,   121,   122,
   123,   124,   125,   126,   127,   128,    -1,   630,    -1,    94,
    -1,    -1,    -1,    -1,   137,    -1,    -1,    -1,    -1,    -1,
    -1,    44,    -1,    -1,   109,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,   655,    56,    57,   120,   121,   122,   123,   124,
   125,   126,   127,   128,    -1,    -1,   669,   670,   671,   672,
   673,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    82,
    -1,    -1,    -1,    -1,    -1,    -1,    89,    90,    91,    92,
    93,    -1,    95,    96,    97,    -1,    99,   100,   101,   102,
   103,   104,   105,   106,   107,   108,    -1,   110,   111,   112,
   113,   114,   115,    -1,     3,     4,    -1,    94,   121,   122,
    -1,   124,   125,   126,    13,    -1,    -1,    -1,    17,   132,
    -1,   134,   109,    -1,    -1,    -1,    -1,    -1,    -1,   116,
    -1,   118,   119,   120,   121,   122,   123,   124,   125,   126,
   127,   128,    -1,    -1,    94,    44,    -1,    -1,    -1,    -1,
   137,    -1,    -1,    -1,    -1,    -1,    -1,    56,    57,   109,
    -1,    -1,    -1,    -1,    -1,    -1,   116,    -1,   118,   119,
   120,   121,   122,   123,   124,   125,   126,   127,   128,    -1,
    -1,    -1,    -1,    82,    -1,    -1,    -1,   137,    -1,    -1,
    89,    90,    91,    92,    93,    -1,    95,    96,    97,    -1,
    99,   100,   101,   102,   103,   104,   105,   106,   107,   108,
    -1,   110,   111,   112,   113,   114,   115,    -1,     3,     4,
    -1,    94,   121,   122,    -1,   124,   125,   126,    13,    -1,
    -1,    -1,    17,   132,    -1,   134,   109,    -1,    -1,    -1,
    -1,    -1,    -1,   116,    -1,   118,   119,   120,   121,   122,
   123,   124,   125,   126,   127,   128,    -1,    -1,    94,    44,
    -1,    -1,    -1,    -1,   137,    -1,    -1,    -1,    -1,    -1,
    -1,    56,    57,   109,    -1,    -1,    -1,    -1,    -1,    -1,
   116,    -1,   118,   119,   120,   121,   122,   123,   124,   125,
   126,   127,   128,    -1,    -1,    -1,    -1,    82,    -1,    -1,
    -1,   137,    -1,    -1,    89,    90,    91,    92,    93,    -1,
    95,    96,    97,    -1,    99,   100,   101,   102,   103,   104,
   105,   106,   107,   108,    -1,   110,   111,   112,   113,   114,
   115,     3,     4,   118,    -1,    94,   121,   122,    -1,   124,
   125,    13,    -1,    -1,    -1,    17,    -1,   132,    -1,   134,
   109,    -1,    -1,    -1,    -1,    -1,    -1,   116,    -1,   118,
   119,   120,   121,   122,   123,   124,   125,   126,   127,   128,
    -1,    94,    44,    -1,    -1,    -1,   135,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    56,    57,   109,    -1,    -1,    -1,
    -1,    -1,    -1,   116,    -1,   118,   119,   120,   121,   122,
   123,   124,   125,   126,   127,   128,    -1,    -1,    -1,    -1,
    82,    -1,   135,    -1,    -1,    -1,    -1,    89,    90,    91,
    92,    93,    -1,    95,    96,    97,    -1,    99,   100,   101,
   102,   103,   104,   105,   106,   107,   108,    -1,   110,   111,
   112,   113,   114,   115,     3,     4,    94,   119,    -1,   121,
   122,    -1,   124,   125,    13,    -1,    -1,    -1,    17,    -1,
   132,   109,   134,    -1,    -1,    -1,    -1,    -1,   116,    -1,
   118,   119,   120,   121,   122,   123,   124,   125,   126,   127,
   128,    94,    -1,    -1,    -1,    44,    -1,   135,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,   109,    56,    57,    -1,
    -1,    -1,    -1,   116,    -1,   118,   119,   120,   121,   122,
   123,   124,   125,   126,   127,   128,    -1,    -1,    -1,    -1,
    -1,    -1,   135,    82,    -1,    -1,    -1,    -1,    -1,    -1,
    89,    90,    91,    92,    93,    -1,    95,    96,    97,    -1,
    99,   100,   101,   102,   103,   104,   105,   106,   107,   108,
    -1,   110,   111,   112,   113,   114,   115,     3,     4,    94,
    -1,   120,   121,   122,    -1,   124,   125,    13,    -1,    -1,
    -1,    17,    -1,   132,   109,   134,    -1,    -1,    -1,    -1,
    -1,   116,    -1,   118,   119,   120,   121,   122,   123,   124,
   125,   126,   127,   128,    94,    -1,    -1,    -1,    44,    -1,
   135,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   109,
    56,    57,    -1,    -1,    -1,    -1,   116,    -1,   118,   119,
   120,   121,   122,   123,   124,   125,   126,   127,   128,    -1,
    -1,    -1,    -1,    -1,    -1,   135,    82,    -1,    -1,    -1,
    -1,    -1,    -1,    89,    90,    91,    92,    93,    -1,    95,
    96,    97,    -1,    99,   100,   101,   102,   103,   104,   105,
   106,   107,   108,    -1,   110,   111,   112,   113,   114,   115,
     3,     4,    94,    -1,   120,   121,   122,    -1,   124,   125,
    13,    -1,    -1,    -1,    17,    -1,   132,   109,   134,    -1,
    -1,    -1,    -1,    -1,   116,    -1,   118,   119,   120,   121,
   122,   123,   124,   125,   126,   127,   128,    94,    -1,    -1,
    -1,    44,    -1,   135,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,   109,    56,    57,    -1,    -1,    -1,    -1,   116,
    -1,   118,   119,   120,   121,   122,   123,   124,   125,   126,
   127,   128,    -1,    -1,    -1,    -1,    -1,    -1,   135,    82,
    -1,    -1,    -1,    -1,    -1,    -1,    89,    90,    91,    92,
    93,    -1,    95,    96,    97,    -1,    99,   100,   101,   102,
   103,   104,   105,   106,   107,   108,    -1,   110,   111,   112,
   113,   114,   115,    -1,     3,     4,    -1,    94,   121,   122,
    -1,   124,   125,   126,    13,    -1,    -1,    -1,    17,   132,
    -1,   134,   109,    -1,    -1,    -1,    -1,    -1,    -1,   116,
    -1,   118,   119,   120,   121,   122,   123,   124,   125,   126,
   127,   128,    -1,    -1,    94,    44,    -1,    -1,   135,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    56,    57,   109,
    -1,    -1,    -1,    -1,    -1,    -1,   116,    -1,   118,   119,
   120,   121,   122,   123,   124,   125,   126,   127,   128,    -1,
    -1,    -1,    -1,    82,    -1,   135,    -1,    -1,    -1,    -1,
    89,    90,    91,    92,    93,    -1,    95,    96,    97,    -1,
    99,   100,   101,   102,   103,   104,   105,   106,   107,   108,
    -1,   110,   111,   112,   113,   114,   115,    -1,     3,     4,
    -1,    94,   121,   122,    -1,   124,   125,   126,    13,    -1,
    -1,    -1,    17,   132,    -1,   134,   109,    -1,    -1,    -1,
    -1,    -1,    -1,   116,    -1,   118,   119,   120,   121,   122,
   123,   124,   125,   126,   127,   128,    -1,    -1,    94,    44,
    -1,    -1,   135,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    56,    57,   109,    -1,    -1,    -1,    -1,    -1,    -1,
   116,    -1,   118,   119,   120,   121,   122,   123,   124,   125,
   126,   127,   128,    -1,    -1,    -1,    -1,    82,    -1,   135,
    -1,    -1,    -1,    -1,    89,    90,    91,    92,    93,    -1,
    95,    96,    97,    -1,    99,   100,   101,   102,   103,   104,
   105,   106,   107,   108,    -1,   110,   111,   112,   113,   114,
   115,    -1,     3,     4,    -1,    94,   121,   122,    -1,   124,
   125,   126,    13,    -1,    -1,    -1,    17,   132,    -1,   134,
   109,    -1,    -1,    -1,    -1,    -1,    -1,   116,    -1,   118,
   119,   120,   121,   122,   123,   124,   125,   126,   127,   128,
    -1,    -1,    94,    44,    -1,    -1,   135,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    56,    57,   109,    -1,    -1,
    -1,    -1,    -1,    -1,   116,    -1,   118,   119,   120,   121,
   122,   123,   124,   125,   126,   127,   128,    -1,    -1,    -1,
    -1,    82,    -1,   135,    -1,    -1,    -1,    -1,    89,    90,
    91,    92,    93,    -1,    95,    96,    97,    -1,    99,   100,
   101,   102,   103,   104,   105,   106,   107,   108,    -1,   110,
   111,   112,   113,   114,   115,    -1,     3,     4,    -1,    94,
   121,   122,    -1,   124,   125,   126,    13,    -1,    -1,    -1,
    17,   132,    -1,   134,   109,    -1,    -1,    -1,    -1,    -1,
    -1,   116,    -1,   118,   119,   120,   121,   122,   123,   124,
   125,   126,   127,   128,    -1,    -1,    94,    44,    -1,    -1,
   135,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    56,
    57,   109,    -1,    -1,    -1,    -1,    -1,    -1,   116,    -1,
   118,   119,   120,   121,   122,   123,   124,   125,   126,   127,
   128,    -1,    -1,    -1,    -1,    82,    -1,   135,    -1,    -1,
    -1,    -1,    89,    90,    91,    92,    93,    -1,    95,    96,
    97,    -1,    99,   100,   101,   102,   103,   104,   105,   106,
   107,   108,    -1,   110,   111,   112,   113,   114,   115,     3,
     4,    94,    -1,    -1,   121,   122,    -1,   124,   125,    13,
    -1,    -1,    -1,    17,    -1,   132,   109,   134,    -1,    -1,
    -1,    -1,    -1,   116,    -1,   118,   119,   120,   121,   122,
   123,   124,   125,   126,   127,   128,    94,    -1,    -1,    -1,
    44,    -1,   135,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,   109,    56,    57,    -1,    -1,    -1,    -1,   116,    -1,
   118,   119,   120,   121,   122,   123,   124,   125,   126,   127,
   128,    -1,    -1,    -1,    -1,    -1,    -1,   135,    82,    -1,
    -1,    -1,    -1,    -1,    -1,    89,    90,    91,    92,    93,
    -1,    95,    96,    97,    -1,    99,   100,   101,   102,   103,
   104,   105,   106,   107,   108,    -1,   110,   111,   112,   113,
   114,   115,    -1,    -1,    -1,    -1,    -1,   121,   122,    -1,
   124,   125,    -1,    -1,     0,     1,    -1,     3,   132,    -1,
   134,     7,     8,     9,    10,    11,    12,    13,    14,    -1,
    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,
    26,    27,    28,    29,    30,    31,    32,    -1,    34,    35,
    36,    37,    38,    39,    40,    41,    42,    43,    44,    45,
    46,    47,    48,    49,    50,    51,    52,    53,    54,    55,
    56,    57,    58,    59,    60,    61,    62,    63,    64,    65,
    66,    67,    68,    69,    70,    71,    72,    73,    74,    75,
    76,    77,    78,    79,    80,    81,    94,    83,    84,    85,
    86,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,   109,    98,    -1,    -1,    -1,    -1,    -1,   116,    -1,
   118,   119,   120,   121,   122,   123,   124,   125,   126,   127,
   128,    94,    -1,    -1,    -1,   121,    -1,   135,    -1,    -1,
    -1,    -1,    -1,    -1,   130,    -1,   109,    -1,    -1,    -1,
    -1,    94,    -1,   116,    -1,   118,   119,   120,   121,   122,
   123,   124,   125,   126,   127,   128,   109,    -1,    -1,    -1,
    -1,    94,   135,   116,    -1,   118,   119,   120,   121,   122,
   123,   124,   125,   126,   127,   128,   109,    -1,    -1,    -1,
    -1,    94,   135,   116,    -1,   118,   119,   120,   121,   122,
   123,   124,   125,   126,   127,   128,   109,    -1,    -1,    -1,
    -1,    94,   135,   116,    -1,   118,   119,   120,   121,   122,
   123,   124,   125,   126,   127,   128,   109,    -1,    -1,    -1,
    -1,    94,   135,   116,    -1,   118,   119,   120,   121,   122,
   123,   124,   125,   126,   127,   128,   109,    -1,    -1,    -1,
    -1,    94,   135,   116,    -1,   118,   119,   120,   121,   122,
   123,   124,   125,   126,   127,   128,   109,    -1,    -1,    -1,
    -1,    94,   135,   116,    -1,   118,   119,   120,   121,   122,
   123,   124,   125,   126,   127,   128,   109,    -1,    -1,    -1,
    -1,    94,   135,   116,    -1,   118,   119,   120,   121,   122,
   123,   124,   125,   126,   127,   128,   109,    -1,    -1,    -1,
    -1,    94,   135,   116,    -1,   118,   119,   120,   121,   122,
   123,   124,   125,   126,   127,   128,   109,    -1,    -1,    -1,
    -1,    94,   135,   116,    -1,   118,   119,   120,   121,   122,
   123,   124,   125,   126,   127,   128,   109,    -1,    -1,    -1,
    -1,    94,   135,   116,    -1,   118,   119,   120,   121,   122,
   123,   124,   125,   126,   127,   128,   109,    -1,    -1,    -1,
    -1,    94,   135,   116,    -1,   118,   119,   120,   121,   122,
   123,   124,   125,   126,   127,   128,   109,    -1,    -1,    -1,
    -1,    94,   135,   116,    -1,   118,   119,   120,   121,   122,
   123,   124,   125,   126,   127,   128,   109,    -1,   131,    -1,
    -1,    94,    -1,   116,    -1,   118,   119,   120,   121,   122,
   123,   124,   125,   126,   127,   128,   109,    -1,   131,    -1,
    -1,    94,    -1,   116,    -1,   118,   119,   120,   121,   122,
   123,   124,   125,   126,   127,   128,   109,    -1,   131,    -1,
    -1,    94,    -1,   116,    -1,   118,   119,   120,   121,   122,
   123,   124,   125,   126,   127,   128,   109,    -1,   131,    -1,
    -1,    94,    -1,   116,    -1,   118,   119,   120,   121,   122,
   123,   124,   125,   126,   127,   128,   109,    -1,   131,    -1,
    -1,    94,    -1,   116,    -1,   118,   119,   120,   121,   122,
   123,   124,   125,   126,   127,   128,   109,    -1,   131,    -1,
    -1,    94,    -1,   116,    -1,   118,   119,   120,   121,   122,
   123,   124,   125,   126,   127,   128,   109,    -1,   131,    -1,
    -1,    94,    -1,   116,    -1,   118,   119,   120,   121,   122,
   123,   124,   125,   126,   127,   128,   109,    -1,   131,    -1,
    -1,    94,    -1,   116,    -1,   118,   119,   120,   121,   122,
   123,   124,   125,   126,   127,   128,   109,    -1,   131,    -1,
    -1,    94,    -1,   116,    -1,   118,   119,   120,   121,   122,
   123,   124,   125,   126,   127,   128,   109,    -1,   131,    -1,
    -1,    94,    -1,   116,   117,   118,   119,   120,   121,   122,
   123,   124,   125,   126,   127,   128,   109,    -1,    -1,    -1,
    -1,    94,    -1,   116,   117,   118,   119,   120,   121,   122,
   123,   124,   125,   126,   127,   128,   109,    -1,    -1,    -1,
    -1,    94,    -1,   116,    -1,   118,   119,   120,   121,   122,
   123,   124,   125,   126,   127,   128,   109,    -1,    -1,    -1,
    -1,    -1,    -1,   116,    -1,   118,   119,   120,    -1,   122,
   123,   124,   125,   126,   127,   128
};
#define YYIMPURE 1

/* #line 2 "bison.simple" */

/* Skeleton output parser for bison,
   copyright (C) 1984 Bob Corbett and Richard Stallman

   Permission is granted to anyone to make or distribute verbatim copies of this program
   provided that the copyright notice and this permission notice are preserved;
   and provided that the recipient is not asked to waive or limit his right to
   redistribute copies as permitted by this permission notice;
   and provided that anyone possessing an executable copy
   is granted access to copy the source code, in machine-readable form,
   in some reasonable manner.

   Permission is granted to distribute derived works or enhanced versions of
   this program under the above conditions with the additional condition
   that the entire derivative or enhanced work
   must be covered by a permission notice identical to this one.

   Anything distributed as part of a package containing portions derived
   from this program, which cannot in current practice perform its function usefully
   in the absense of what was derived directly from this program,
   is to be considered as forming, together with the latter,
   a single work derived from this program,
   which must be entirely covered by a permission notice identical to this one
   in order for distribution of the package to be permitted.

 In other words, you are welcome to use, share and improve this program.
 You are forbidden to forbid anyone else to use, share and improve
 what you give them.   Help stamp out software-hoarding!  */

/* Note that this is not the current license condition for bison parsers,
   but VMS makes it too much of a hassle to upgrade SM to ship a newer
   version. RHL */

/* This is the parser code that is written into each bison parser
  when the %semantic_parser declaration is not specified in the grammar.
  It was written by Richard Stallman by simplifying the hairy parser
  used when %semantic_parser is specified.  */

/* Note: there must be only one dollar sign in this file.
   It is replaced by the list of actions, each action
   as one case of the switch.  */

#define SMBISON			/* this is the ancient version of bison
				   distributed with SM */

#ifdef sparc
#include <alloca.h>
#endif
#define yyerrok		(yyerrstatus = 0)
#define yyclearin	(yychar = YYEMPTY)
#define YYEMPTY		-2
#define YYEOF		0
#define YYFAIL		goto yyerrlab;

#define YYTERROR	1

#ifndef YYIMPURE
#define YYLEX		yylex()
#endif

#ifndef YYPURE
#define YYLEX		yylex(&yylval, &yylloc)
#endif

/* If nonreentrant, generate the variables here */

#ifndef YYIMPURE

int	yychar;			/*  the lookahead symbol		*/
YYSTYPE	yylval;			/*  the semantic value of the		*/
				/*  lookahead symbol			*/

YYLTYPE yylloc;			/*  location data for the lookahead	*/
				/*  symbol				*/

int yydebug = 0;		/*  nonzero means print parse trace	*/

#endif  /* YYIMPURE */


/*  YYMAXDEPTH indicates the initial size of the parser's stacks	*/

#ifndef	YYMAXDEPTH
#define YYMAXDEPTH 10000
#endif

/*  YYMAXLIMIT is the maximum size the stacks can grow to
    (effective only if the built-in stack extension method is used).  */

#ifndef YYMAXLIMIT
#define YYMAXLIMIT 500000
#endif


/* #line 87 "bison.simple" */
int
yyparse()
{

/*Auto Variables*/
   char buff[MACROSIZE + 1],	/* buffer for reading macros */
	       word[CHARMAX];		/* buffer for storing WORD */
   char variable_name[CHARMAX];		/* name of variable being defined */
/*End Auto Variables*/
  register int yystate;
  register int yyn;
  register short *yyssp;
  register YYSTYPE *yyvsp;
  YYLTYPE *yylsp;
  int yyerrstatus;	/*  number of tokens to shift before error messages enabled */
  int yychar1;		/*  lookahead token as an internal (translated) token number */

  short	yyssa[YYMAXDEPTH];	/*  the state stack			*/
  YYSTYPE yyvsa[YYMAXDEPTH];	/*  the semantic value stack		*/
  YYLTYPE yylsa[YYMAXDEPTH];	/*  the location stack			*/

  short *yyss = yyssa;		/*  refer to the stacks thru separate pointers */
  YYSTYPE *yyvs = yyvsa;	/*  to allow yyoverflow to reallocate them elsewhere */
  YYLTYPE *yyls = yylsa;

  int yymaxdepth = YYMAXDEPTH;

#ifndef YYPURE

  int yychar;
  YYSTYPE yylval;
  YYLTYPE yylloc;

  extern int yydebug;

#endif


  YYSTYPE yyval;		/*  the variable used to return		*/
				/*  semantic values from the action	*/
				/*  routines				*/

  int yylen;

  if (yydebug)
    fprintf(stderr, "Starting parse\n");

  yystate = 0;
  yyerrstatus = 0;
  yychar = YYEMPTY;		/* Cause a token to be read.  */

  /* Initialize stack pointers.
     Waste one element of value and location stack
     so that they stay on the same level as the state stack.  */

  // JCM: Below line causes segfault sometimes.  Increased stack to see if avoided.  Otherwise, should turn off optimizations to see what is going on.
  yyssp = yyss - 1;
  yyvsp = yyvs;
  yylsp = yyls;

/* Push a new state, which is found in  yystate  .  */
/* In all cases, when you get here, the value and location stacks
   have just been pushed. so pushing a state here evens the stacks.  */
yynewstate:

  *++yyssp = yystate;

  if (yyssp >= yyss + yymaxdepth - 1)
    {
      /* Give user a chance to reallocate the stack */
      /* Use copies of these so that the &'s don't force the real ones into memory. */
      YYSTYPE *yyvs1 = yyvs;
      YYLTYPE *yyls1 = yyls;
      short *yyss1 = yyss;

      /* Get the current used size of the three stacks, in elements.  */
      int size = yyssp - yyss + 1;

#ifdef yyoverflow
      /* Each stack pointer address is followed by the size of
	 the data in use in that stack, in bytes.  */
      yyoverflow("parser stack overflow",
		 &yyss1, size * sizeof (*yyssp),
		 &yyvs1, size * sizeof (*yyvsp),
		 &yyls1, size * sizeof (*yylsp),
		 &yymaxdepth);

      yyss = yyss1; yyvs = yyvs1; yyls = yyls1;
#else /* no yyoverflow */
      /* Extend the stack our own way.  */
      if (yymaxdepth >= YYMAXLIMIT)
	yyerror("parser stack overflow");
      yymaxdepth *= 2;
      if (yymaxdepth > YYMAXLIMIT)
	yymaxdepth = YYMAXLIMIT;
      yyss = (short *) alloca (yymaxdepth * sizeof (*yyssp));
      bcopy ((char *)yyss1, (char *)yyss, size * sizeof (*yyssp));
      yyls = (YYLTYPE *) alloca (yymaxdepth * sizeof (*yylsp));
      bcopy ((char *)yyls1, (char *)yyls, size * sizeof (*yylsp));
      yyvs = (YYSTYPE *) alloca (yymaxdepth * sizeof (*yyvsp));
      bcopy ((char *)yyvs1, (char *)yyvs, size * sizeof (*yyvsp));
#endif /* no yyoverflow */

      yyssp = yyss + size - 1;
      yylsp = yyls + size - 1;
      yyvsp = yyvs + size - 1;

      if (yydebug)
	fprintf(stderr, "Stack size increased to %d\n", yymaxdepth);

      if (yyssp >= yyss + yymaxdepth - 1)
	YYERROR;
    }

  if (yydebug)
    fprintf(stderr, "Entering state %d\n", yystate);

/* Do appropriate processing given the current state.  */
/* Read a lookahead token if we need one and don't already have one.  */
#if 0			/* Not referenced by SM parser */
yyresume:
#endif

  /* First try to decide what to do without reference to lookahead token.  */

  yyn = yypact[yystate];
  if (yyn == YYFLAG)
    goto yydefault;

  /* Not known => get a lookahead token if don't already have one.  */

  /* yychar is either YYEMPTY or YYEOF
     or a valid token in external form.  */

  if (yychar == YYEMPTY)
    {
      yychar = YYLEX;
    }

  /* Convert token to internal form (in yychar1) for indexing tables with */

  if (yychar <= 0)		/* This means end of input. */
    {
      yychar1 = 0;
      yychar = YYEOF;		/* Don't call YYLEX any more */

      if (yydebug)
	fprintf(stderr, "Now at end of input.\n");
    }
  else
    {
      yychar1 = YYTRANSLATE(yychar);

      if (yydebug)
	fprintf(stderr, "Parsing next token; it is %d (%s)\n", yychar, yytname[yychar1]);
    }

  yyn += yychar1;
  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
    goto yydefault;

  yyn = yytable[yyn];

  /* yyn is what to do for this token type in this state.
     Negative => reduce, -yyn is rule number.
     Positive => shift, yyn is new state.
       New state is final state => don't bother to shift,
       just return success.
     0, or most negative number => error.  */

  if (yyn < 0)
    {
      if (yyn == YYFLAG)
	goto yyerrlab;
      yyn = -yyn;
      goto yyreduce;
    }
  else if (yyn == 0)
    goto yyerrlab;

  if (yyn == YYFINAL)
    YYACCEPT;

  /* Shift the lookahead token.  */

  if (yydebug)
    fprintf(stderr, "Shifting token %d (%s), ", yychar, yytname[yychar1]);

  /* Discard the token being shifted unless it is eof.  */
  if (yychar != YYEOF)
    yychar = YYEMPTY;

  *++yyvsp = yylval;
  *++yylsp = yylloc;

  /* count tokens shifted since error; after three, turn off error status.  */
  if (yyerrstatus) yyerrstatus--;

  yystate = yyn;
  goto yynewstate;

/* Do the default action for the current state.  */
yydefault:

  yyn = yydefact[yystate];
  if (yyn == 0)
    goto yyerrlab;

/* Do a reduction.  yyn is the number of a rule to reduce with.  */
yyreduce:
  yylen = yyr2[yyn];
  yyval = yyvsp[1-yylen]; /* implement default value of the action */

  if (yydebug)
    {
      if (yylen == 1)
	fprintf (stderr, "Reducing 1 value via line %d, ",
		 yyrline[yyn]);
      else
	fprintf (stderr, "Reducing %d values via line %d, ",
		 yylen, yyrline[yyn]);
    }


  switch (yyn) {

case 1:
/* #line 124 "control.y" */
{
#if defined(YYFAIL)
#  undef  YYERROR			/* work around for Bison bug */
#  define YYERROR YYFAIL		/* must be here, not in preamble */
#endif
	    start_line();
	 ;
    break;}
case 3:
/* #line 135 "control.y" */
{
	    fflush(stdout); fflush(stderr);
	    if(buff_is_empty()) {	/* no characters on input buffer */
	       if(graph_mode) {
		  IDLE();		/* out of graphics mode */
		  graph_mode = 0;
	       }
	       return(1);
	    }
	    start_line();		/* start a new line in tokens.c */
	 ;
    break;}
case 4:
/* #line 147 "control.y" */
{
	    char cmd[200];		/* command to execute */
	    char *shell;		/* the shell to use */

	    reset_term();
	    (void)mgets(cmd,MACROSIZE);	/* read rest of line */
	    if(*(shell = print_var("SHELL")) != '\0' &&
						strcmp(shell,"/bin/sh") != 0) {
	       sprintf(buff,"%s -c \"%s\"",shell,cmd);
	       set_exit_status(system(buff));
	    } else {
	       set_exit_status(system(cmd));
	    }
	    set_term();
	 ;
    break;}
case 5:
/* #line 163 "control.y" */
{
	    abort_plot = 1;
	    if(graph_mode) { IDLE(); graph_mode = 0; }
	    CLOSE(); stg_close();
	    devnum = NODEVICE;
	    SETUP("");
	    if(in_graphics) { ENABLE(); graph_mode = 1; }
	    set_dev();
	    abort_plot = 0;
	 ;
    break;}
case 6:
/* #line 174 "control.y" */
{
	    set_angle(yyvsp[0].vector.vec.f,yyvsp[0].vector.dimen);
	    vec_free(&yyvsp[0].vector);
	 ;
    break;}
case 7:
/* #line 179 "control.y" */
{
	    (void)mgets(buff,CHARMAX);	/* read rest of line */
	    help_apropos(&buff[1]);
	    macro_apropos(&buff[1]);
	 ;
    break;}
case 8:
/* #line 185 "control.y" */
{ set_aspect( yyvsp[0].floatval ); ;
    break;}
case 9:
/* #line 187 "control.y" */
{
	    if(yyvsp[0].charval[0] == '~') {
	       if(getenv("HOME") == NULL) {
		  msg("can't expand ~  : HOME is not defined\n");
		  (void)strcpy(buff,yyvsp[0].charval);
	       }
	       (void)sprintf(buff,"%s%s",getenv("HOME"),&yyvsp[0].charval[1]);
	    } else {
	       (void)strcpy(buff,yyvsp[0].charval);
	    }
#if 0 && defined(VMS)			/* let's see if this works */
	    msg("Chdir is not currently provided, due to a VMS bug\n");
	    break;
#endif
#if defined(__MSDOS__)
	    if(buff[1] == ':') {
	       setdisk(isupper(buff[0]) ? tolower(buff[0]) : buff[0]);
	       if(buff[2] == '\0') break;
	    }
#endif
	    if(chdir(buff) != 0) {
	       perror("Error in CHDIR ");
	    }
	 ;
    break;}
case 10:
/* #line 212 "control.y" */
{
	    sm_cursor(0);
	    sm_disable();
            (void)unput('\n');
	 ;
    break;}
case 11:
/* #line 218 "control.y" */
{
	    set_cursor_vectors(yyvsp[-1].charval,yyvsp[0].charval,(char *)NULL);
	    sm_disable();
	 ;
    break;}
case 12:
/* #line 223 "control.y" */
{
	    FILE *fil;

	    if((fil = fopen(yyvsp[0].charval,"r")) == NULL) {
	       msg_1s("Can't open %s\n",yyvsp[0].charval);
	    } else {
	       (void)fclose(fil);
	    }
	    (void)strncpy(data_file,yyvsp[0].charval,CHARMAX); /* the file to read data */
	    line_1 = line_2 = 0;	/* no lines specified */
	    subtable = -1;		/* we aren't reading a table */
	    set_data_file(yyvsp[0].charval);
	 ;
    break;}
case 13:
/* #line 237 "control.y" */
{ ; ;
    break;}
case 14:
/* #line 238 "control.y" */
{ if(variable_name[0] != '\0') make_local_variable(variable_name); ;
    break;}
case 15:
/* #line 239 "control.y" */
{ ; ;
    break;}
case 16:
/* #line 241 "control.y" */
{
	    delete_last_history(1);	/* forget this command */
	    delete_last_history(1);	/* and the last one too */
	 ;
    break;}
case 17:
/* #line 246 "control.y" */
{ delete_history(yyvsp[0].intval,yyvsp[0].intval,1); ;
    break;}
case 18:
/* #line 248 "control.y" */
{ delete_history(yyvsp[-1].intval,yyvsp[0].intval,1); ;
    break;}
case 19:
/* #line 250 "control.y" */
{ delete_last_history(0); ;
    break;}
case 20:
/* #line 252 "control.y" */
{ delete_last_history(1); ;
    break;}
case 21:
/* #line 254 "control.y" */
{ delete_history(yyvsp[0].intval,yyvsp[0].intval,0); ;
    break;}
case 22:
/* #line 256 "control.y" */
{ delete_history(yyvsp[-1].intval,yyvsp[0].intval,0); ;
    break;}
case 23:
/* #line 258 "control.y" */
{ (void)free_vector(yyvsp[0].charval); ;
    break;}
case 24:
/* #line 260 "control.y" */
{
	      if(graph_mode) IDLE();
	      CLOSE(); stg_close();
	      devnum = NODEVICE;

	      (void)mgets(word,CHARMAX); /* read rest of line */
	      if(yyvsp[0].intval >= 0 && yyvsp[0].intval < ndev) {
		 if((*devices[yyvsp[0].intval].dev_setup)(word) >= 0) {
		    devnum = yyvsp[0].intval;
		 } else {
		    msg_1s("No such device %s\n",word);
		 }
	      } else {
	         msg_1d("No such device %d\n",yyvsp[0].intval);
	      }
	      ENABLE(); graph_mode = 1;
	      set_dev();
	   ;
    break;}
case 25:
/* #line 279 "control.y" */
{
	      if(strcmp(yyvsp[0].charval,"close") == 0 || strcmp(yyvsp[0].charval,"CLOSE") == 0) {
		 close_metafile();
	      } else {
		 open_metafile(yyvsp[0].charval);
	      }
	   ;
    break;}
case 26:
/* #line 287 "control.y" */
{
    	      int dn, len;

	      if(graph_mode) IDLE();
	      CLOSE(); stg_close();
	      devnum = NODEVICE;

	      (void)sprintf(buff,"%s",yyvsp[0].charval);
	      len = strlen(buff);
	      (void)mgets(&buff[len],MACROSIZE - len); /* read rest of line */

	      if((dn = stg_setup(buff)) < 0) {
		 devnum = NODEVICE;
		 msg_1s("No such device %s\n",buff);
	      } else {
		 devnum = dn;
	      }

	      ENABLE(); graph_mode = 1;
	      set_dev();
	   ;
    break;}
case 27:
/* #line 309 "control.y" */
{
	    if(sm_dither(yyvsp[-4].charval, yyvsp[-3].charval, yyvsp[-2].floatval, yyvsp[-1].floatval, yyvsp[0].intval) < 0) {
	       break;
	    }
	 ;
    break;}
case 28:
/* #line 315 "control.y" */
{
	    if(variable_name[0] == '\0' || yyvsp[-1].strval.start == NULL) {
	       if(yyvsp[-1].strval.start != NULL) free(yyvsp[-1].strval.start);
	       break;
	    }

	    push_dstack(variable_name,yyvsp[-6].floatval,yyvsp[-4].floatval,yyvsp[-3].floatval); /* set up DO variables */
	    if(next_do() == 0) {	/* set intial value of DO variable */
	       push(yyvsp[-1].strval.start,S_DO);	/* push body of DO loop */
	    }
         ;
    break;}
case 29:
/* #line 326 "control.y" */
{ (void)mscanstr(yyval.charval,CHARMAX); ;
    break;}
case 30:
/* #line 327 "control.y" */
{ define_map(yyvsp[-1].charval,yyvsp[0].charval); ;
    break;}
case 31:
/* #line 329 "control.y" */
{
	    lexflush();			/* flush lex buffer */
            yyerrok;
            yyclearin;			/* reset the parser */
	    start_line();		/* start a new line in tokens.c */
	    if(graph_mode) {
	       IDLE();
	       graph_mode = 0;
	    }
	    if(recurse_lvl) {
	       if(recurse_lvl > 1) {	/* keep on popping */
		  push("SNARK ",S_TEMP);
	       }
	       recurse_lvl--;
	       return(1);
	    }
	    if(buff_is_empty()) {	/* no characters on input buffer */
	       return(1);
	    }
         ;
    break;}
case 32:
/* #line 350 "control.y" */
{
	    set_expand(yyvsp[0].vector.vec.f,yyvsp[0].vector.dimen);
	    vec_free(&yyvsp[0].vector);
	 ;
    break;}
case 33:
/* #line 355 "control.y" */
{
	    VECTOR *temp_r,*temp_i;
	    
	    if(yyvsp[-4].floatval != 1 && yyvsp[-4].floatval != -1) {
	       msg_1f("You must specify 1 or -1 for an FFT, not %g\n",yyvsp[-4].floatval);
	       vec_free(&yyvsp[-3].vector);
	       vec_free(&yyvsp[-2].vector);
	       break;
	    }
	    if(yyvsp[-3].vector.dimen != yyvsp[-2].vector.dimen) {
	       msg_2s("Vectors %s and %s have different dimensions\n",
		      yyvsp[-3].vector.name,yyvsp[-2].vector.name);
	       vec_free(&yyvsp[-3].vector);
	       vec_free(&yyvsp[-2].vector);
	       break;
	    }
	    if((temp_r = make_vector(yyvsp[-1].charval,yyvsp[-3].vector.dimen,VEC_FLOAT)) == NULL) {
	       vec_free(&yyvsp[-3].vector);
	       vec_free(&yyvsp[-2].vector);
	       break;
	    }
	    if((temp_i = make_vector(yyvsp[0].charval,yyvsp[-3].vector.dimen,VEC_FLOAT)) == NULL) {
	       vec_free(&yyvsp[-3].vector);
	       vec_free(&yyvsp[-2].vector);
	       free_vector(yyvsp[-1].charval);
	       break;
	    }
	    (void)fft(yyvsp[-3].vector.vec.f,yyvsp[-2].vector.vec.f,temp_r->vec.f,temp_i->vec.f,yyvsp[-3].vector.dimen,
								      (int)yyvsp[-4].floatval);
	    vec_free(&yyvsp[-3].vector);
	    vec_free(&yyvsp[-2].vector);
	 ;
    break;}
case 34:
/* #line 388 "control.y" */
{
	    if(variable_name[0] == '\0' || yyvsp[-3].t_list == NULL || yyvsp[-1].strval.start == NULL) {
	       freelist(yyvsp[-3].t_list);
	       if(yyvsp[-1].strval.start != NULL) free(yyvsp[-1].strval.start);
	       break;
	    }
	    if(yyvsp[-3].t_list->nitem <= 0) {	/* Null list */
	       msg_1s("FOREACH %s variable list is empty\n",variable_name);
	       freelist(yyvsp[-3].t_list);
	       free(yyvsp[-1].strval.start);
	       break;
	    }
	    push_fstack(variable_name,yyvsp[-3].t_list);
	    (void)next_foreach();
	    push(yyvsp[-1].strval.start,S_FOREACH);	/* $3 and $5 will be freed later */
         ;
    break;}
case 35:
/* #line 405 "control.y" */
{ sm_format( yyvsp[-1].charval, yyvsp[0].charval ); ;
    break;}
case 36:
/* #line 407 "control.y" */
{
	    sm_format("1","1");
	    (void)unput('\n');
	 ;
    break;}
case 37:
/* #line 411 "control.y" */
{
	   in_graphics = 1;
	   if(!graph_mode) { ENABLE(); graph_mode = 1; }
        ;
    break;}
case 38:
/* #line 416 "control.y" */
{ in_graphics = 0; GFLUSH(); ;
    break;}
case 39:
/* #line 418 "control.y" */
{
	    char *var;
	    int i,j;

	    if(graph_mode) { IDLE(); graph_mode = 0; }
            (void)mgets(word,CHARMAX);	/* will have leading ' ' */
	    for(j = strlen(word) - 1;j >= 0 && isspace(word[j]);j--) {
	       word[j] = '\0';
	    }
	    for(i = 0;i < j && isspace(word[i]);i++) continue;
	    if(word[i] == '\0') {
	       (void)strcpy(word,"help");
	       i = 0;
	    }
            if((j = help(&word[i])) < 0) {	/* in help directory? */
	       break;
	    }
            j += (what_is(&word[i]) == 0);	/* maybe it's a macro */
	    var = print_var(&word[i]);
	    j += (var[0] != '\0');		/* or a variable? */
	    if(var[0] != '\0') {
	       (void)printf("Variable : %s\n",var);
	    }
	    j += (help_vector(&word[i]) == 0);	/* maybe a vector? */
	    if(j == 0) {			/* nothing we know about */
	       (void)fprintf(stderr,"I'm sorry %s, %s\n",user_name,
					  "but I can't help you with that.");
            }
	    fflush(stdout);
         ;
    break;}
case 40:
/* #line 449 "control.y" */
{ history_list(1); ;
    break;}
case 41:
/* #line 451 "control.y" */
{ history_list(-1); ;
    break;}
case 42:
/* #line 453 "control.y" */
{
	    (void)unput('\n');
	    if(yyvsp[-2].strval.start == NULL) break;
	    if(yyvsp[-5].floatval) {
	       push(yyvsp[-2].strval.start,S_TEMP);
	    } else {
	       free(yyvsp[-2].strval.start);
	    }
	 ;
    break;}
case 43:
/* #line 463 "control.y" */
{
	    char *if_body;
	    
	    if(yyvsp[-5].strval.start == NULL) {
	       if(yyvsp[-1].strval.start != NULL) free(yyvsp[-1].strval.start);
	       break;
	    }
	    if(yyvsp[-1].strval.start == NULL) {
	       free(yyvsp[-5].strval.start);
	       break;
	    }
	    
	    if(yyvsp[-8].floatval) {
	       free(yyvsp[-1].strval.start);
	       if_body = yyvsp[-5].strval.start;
	    } else {
	       free(yyvsp[-5].strval.start);
	       if_body = yyvsp[-1].strval.start;
	    }

	    push(if_body,S_TEMP);
	 ;
    break;}
case 44:
/* #line 486 "control.y" */
{
	    sm_cursor(1);
	    sm_disable();
            (void)unput('\n');
	 ;
    break;}
case 45:
/* #line 492 "control.y" */
{
	    set_cursor_vectors(yyvsp[-2].charval,yyvsp[-1].charval,yyvsp[0].charval);
	    sm_disable();
            (void)unput('\n');
	 ;
    break;}
case 46:
/* #line 498 "control.y" */
{ (void)sm_delimage(); ;
    break;}
case 47:
/* #line 500 "control.y" */
{ (void)read_image(yyvsp[0].charval,0.0,0.0,0.0,0.0); ;
    break;}
case 48:
/* #line 502 "control.y" */
{ (void)read_image(yyvsp[-4].charval,yyvsp[-3].floatval,yyvsp[-2].floatval,yyvsp[-1].floatval,yyvsp[0].floatval); ;
    break;}
case 49:
/* #line 504 "control.y" */
{ create_image(yyvsp[-3].intval,yyvsp[-1].intval,0.0,(float)yyvsp[-3].intval - 1,0.0,(float)yyvsp[-1].intval - 1); ;
    break;}
case 50:
/* #line 506 "control.y" */
{ create_image(yyvsp[-7].intval,yyvsp[-5].intval,yyvsp[-3].floatval,yyvsp[-2].floatval,yyvsp[-1].floatval,yyvsp[0].floatval); ;
    break;}
case 51:
/* #line 508 "control.y" */
{
	    sm_levels(yyvsp[0].vector.vec.f,(int)yyvsp[0].vector.dimen);
	    vec_free(&yyvsp[0].vector);
         ;
    break;}
case 52:
/* #line 513 "control.y" */
{
	    if(fabs(x_range) > 1e-20) {
	       yyvsp[-1].pairval.a = yyvsp[-1].pairval.med - x_range/2;
	       yyvsp[-1].pairval.b = yyvsp[-1].pairval.med + x_range/2;
	    }
	    if(fabs(y_range) > 1e-20) {
	       yyvsp[0].pairval.a = yyvsp[0].pairval.med - y_range/2;
	       yyvsp[0].pairval.b = yyvsp[0].pairval.med + y_range/2;
	    }
	    (void)sm_limits( yyvsp[-1].pairval.a, yyvsp[-1].pairval.b, yyvsp[0].pairval.a, yyvsp[0].pairval.b );
	 ;
    break;}
case 53:
/* #line 525 "control.y" */
{ key_macro(); ;
    break;}
case 54:
/* #line 527 "control.y" */
{
	    line_1 = yyvsp[-1].intval;
	    line_2 = yyvsp[0].intval;
	    sprintf(buff,"%d",line_1); setvar("_l1",buff);
	    sprintf(buff,"%d",line_2); setvar("_l2",buff);
	 ;
    break;}
case 55:
/* #line 533 "control.y" */
{ disable_overload(); ;
    break;}
case 56:
/* #line 533 "control.y" */
{ allow_overload(); ;
    break;}
case 57:
/* #line 535 "control.y" */
{ (void)sm_location( yyvsp[-3].intval, yyvsp[-2].intval, yyvsp[-1].intval, yyvsp[0].intval); ;
    break;}
case 58:
/* #line 537 "control.y" */
{
	    if(yyvsp[0].floatval < 0) {
	       msg("LWEIGHT cannot be negative; setting to zero\n");
	       yyvsp[0].floatval = 0;
	    }
	    sm_lweight(yyvsp[0].floatval);
	 ;
    break;}
case 59:
/* #line 545 "control.y" */
{
	    if(yyvsp[0].strval.start == NULL) break;
            *(yyvsp[0].strval.end) = '\0';		/* remove '\n' */
	    sprintf(buff,"%d",yyvsp[-1].intval);
            (void)define_s(yyvsp[-2].charval,yyvsp[0].strval.start,buff);

            free(yyvsp[0].strval.start);
         ;
    break;}
case 60:
/* #line 554 "control.y" */
{ (void)define(yyvsp[-1].charval,"delete",0,0,0); ;
    break;}
case 61:
/* #line 556 "control.y" */
{ (void)define_history_macro(yyvsp[-2].charval,yyvsp[-1].intval,yyvsp[0].intval);;
    break;}
case 62:
/* #line 558 "control.y" */
{ (void)macro_edit(yyvsp[0].charval); ;
    break;}
case 63:
/* #line 560 "control.y" */
{
	    FILE *fil;

	    if((fil = fopen(yyvsp[0].charval,"r")) == NULL) {
	       msg_1s("can't open %s\n",yyvsp[0].charval);
	       break;
	    }
	    (void)read_macros(fil);
	    (void)fclose(fil);
	 ;
    break;}
case 64:
/* #line 571 "control.y" */
{ (void)undefine_macros(yyvsp[0].charval); ;
    break;}
case 65:
/* #line 573 "control.y" */
{
	    FILE *fil;

            (void)unput('\n');
	    if(would_clobber(yyvsp[-1].charval)) {
	       break;
	    }
	    if((fil = fopen(yyvsp[-1].charval,"w")) == NULL) {
	       msg_1s("can't open %s\n",yyvsp[-1].charval);
	       break;
	    }
            (void)write_macros(fil,1);	/* write all macros */
	    (void)fclose(fil);
         ;
    break;}
case 66:
/* #line 588 "control.y" */
{ (void)write_one_macro(yyvsp[-2].charval,yyvsp[0].charval,(yyvsp[-1].intval == '+')); ;
    break;}
case 67:
/* #line 590 "control.y" */
{ playback_metafile(yyvsp[0].charval); ;
    break;}
case 68:
/* #line 592 "control.y" */
{
	    float min,max;

	    sm_minmax(&min,&max);
	    (void)sprintf(buff,"%.10g",min);
	    setvar(yyvsp[-1].charval,buff);
	    (void)sprintf(buff,"%.10g",max);
	    setvar(yyvsp[0].charval,buff);
	 ;
    break;}
case 69:
/* #line 602 "control.y" */
{ sm_notation( yyvsp[-3].floatval, yyvsp[-2].floatval, yyvsp[-1].floatval, yyvsp[0].floatval ); ;
    break;}
case 70:
/* #line 604 "control.y" */
{ overload(variable_name,yyvsp[0].intval); ;
    break;}
case 71:
/* #line 606 "control.y" */
{
	    int append = (yyvsp[-3].intval == '+');  
	    int dimen = 0,i,nvec;
	    VECTOR **temp;

	    if(!append && would_clobber(yyvsp[-2].charval)) {
	       break;
	    }
	    if(graph_mode) { graph_mode = 0; IDLE(); }

	    nvec = yyvsp[0].t_list->nitem;
	    if((temp = (VECTOR **)malloc(nvec*sizeof(VECTOR *))) == NULL) {
	       msg("Can't allocate storage for temp\n");
	       break;
	    }

	    for(i = 0;i < nvec && !sm_interrupt;i++) {	/* get vectors */
	       if((temp[i] = get_vector_ptr(yyvsp[0].t_list->i_list[i]->str)) == NULL) {
		  break;
	       }
	       if(i == 0) {
		  dimen = temp[0]->dimen;
	       } else if(temp[i]->dimen != dimen) {
		  if(sm_verbose > 1)
		     msg("Vectors are different sizes\n");
		  if(dimen < temp[i]->dimen) {
		     dimen = temp[i]->dimen;
		  }
	       }
	    }
	    if(i < nvec) {
	       free((char *)temp);
               freelist(yyvsp[0].t_list);
	       break;
	    }

	    print_vec(yyvsp[-2].charval,append ? "a" : "w",yyvsp[-1].charval,nvec,temp,dimen);
	    
	    free((char *)temp);
            freelist(yyvsp[0].t_list);
	 ;
    break;}
case 72:
/* #line 648 "control.y" */
{
	    int i;

	    (void)mgets(buff,100);
	    for(plength = 0,i = 0;buff[i + 1] != '\0';i++) {
	       prompt[i] = buff[i + 1];
	       if(prompt[i] == '*') prompt[i] = '\007'; /* replace * with ^G */
	       if(isprint(prompt[i])) plength++;
	    }
	    plength++;			/* allow for ' ' */
	    prompt[i] = '\0';
         ;
    break;}
case 73:
/* #line 661 "control.y" */
{
	    REAL pstyle[1];

	    pstyle[0] = 10*yyvsp[-1].intval + yyvsp[0].intval;
	    sm_ptype( pstyle, 1 );
	 ;
    break;}
case 74:
/* #line 668 "control.y" */
{
	    VECTOR *tptr;

	    if((tptr = get_vector_ptr(yyvsp[0].charval)) == NULL) {
	       break;
	    }
	    switch (tptr->type) {
	     case VEC_FLOAT:
	       sm_ptype(tptr->vec.f,tptr->dimen);
	       break;
	     case VEC_STRING:
	       ptype_str(tptr->name,tptr->vec.s.s_s,tptr->dimen);
	       break;
	     default:
	       msg_1s("%s is an ",yyvsp[0].charval);
	       msg_1d("unknown type of vector: %d\n",tptr->type);
	       break;
	    }
	 ;
    break;}
case 75:
/* #line 688 "control.y" */
{
	    if(yyvsp[-1].vector.type != VEC_FLOAT) {
	       msg_1s("%s is not an arithmetic expression\n",yyvsp[-1].vector.name);
	       break;
	    }
	    sm_ptype( yyvsp[-1].vector.vec.f, yyvsp[-1].vector.dimen );
	    vec_free(&yyvsp[-1].vector);
	 ;
    break;}
case 76:
/* #line 697 "control.y" */
{
	    if(yyvsp[0].t_list == NULL) break;
	    if(yyvsp[0].t_list->nitem <= 0) {	/* Null symbol list */
	       msg("Symbol definition list is empty\n");
	       freelist(yyvsp[0].t_list);
	       break;
	    }	       

	    setsym(yyvsp[0].t_list);
	    freelist(yyvsp[0].t_list);
	 ;
    break;}
case 77:
/* #line 709 "control.y" */
{
	    if(graph_mode) IDLE();
	    CLOSE(); stg_close();
	    return(-1);
	 ;
    break;}
case 78:
/* #line 715 "control.y" */
{
	    x_range = yyvsp[-1].floatval;
	    y_range = yyvsp[0].floatval;
	 ;
    break;}
case 79:
/* #line 720 "control.y" */
{ (void)read_map(yyvsp[0].charval); ;
    break;}
case 80:
/* #line 722 "control.y" */
{ read_old(yyvsp[-1].charval,yyvsp[0].charval); ;
    break;}
case 81:
/* #line 724 "control.y" */
{
	    int col;
	    VECTOR temp;

	    col = atoi(yyvsp[0].charval);
	    temp.type = parse_qualifier(yyvsp[0].charval);
	    temp.name = yyvsp[-1].charval;
	    if(read_row(data_file,col,&temp) == 0) {
	       copy_vector(temp.name,temp);
	    }
	 ;
    break;}
case 82:
/* #line 736 "control.y" */
{
	    int col;
	    VECTOR *tptr,temp;

	    tptr = &temp;
	    col = atoi(yyvsp[0].charval);
	    temp.name = yyvsp[-1].charval;
	    temp.type = parse_qualifier(yyvsp[0].charval);
	    if(read_column(' ',data_file,&col,&tptr,1,line_1,line_2,"") == 1) {
	       copy_vector(temp.name,temp);
	    }
	 ;
    break;}
case 83:
/* #line 749 "control.y" */
{
	    int *cols,			/* desired columns */
	        extra,			/* extra i_list items processed */
	        i,j,k,
	        ncol,nvec,
	        n1,n2,			/* range of columns for a vector */
	        size_cols;		/* size of cols, temp */
	    VECTOR **temp, *temp_s;	/* temporary vectors */

	    yyvsp[-1].intval = (yyvsp[-1].intval == '!') ? 1 : 0;
	    if(yyvsp[0].t_list == NULL) break;
	    ncol = yyvsp[0].t_list->nitem;

	    size_cols = ncol;		/* initially assume no ranges */
	    if((cols = (int *)malloc(size_cols*sizeof(int))) == NULL) {
	       msg("Can't allocate space for columns list\n");
	       break;
	    }
	    if((temp = (VECTOR **)malloc(size_cols*sizeof(VECTOR *))) == NULL){
	       msg("Can't allocate storage for temp\n");
	       free((char *)cols);
	       break;
	    }
	    if((temp_s = (VECTOR *)malloc(size_cols*sizeof(VECTOR))) == NULL){
	       msg("Can't allocate storage for temp_s\n");
	       free((char *)temp);
	       free((char *)cols);
	       break;
	    }
	    for(i = 0;i < size_cols;i++) {
	       temp[i] = temp_s + i;
	       temp[i]->name = temp[i]->descrip + 1;
	    }

	    for(i = j = 0;i < ncol;i += 2 + extra) {
	       if(i + 1 == ncol) {
		  msg_1s("Ignoring extra field at end of READ list: %s\n",
			 yyvsp[0].t_list->i_list[i]->str);
		  break;
	       }
	       extra = 0;
	       if(strchr(yyvsp[0].t_list->i_list[i + 1]->str,'-') != NULL) {
		  char *ptr = yyvsp[0].t_list->i_list[i + 1]->str;
		  if(*ptr == '-') {	/* a single -ve number */
		     n1 = n2 = atoi(ptr);
		  } else {
		     n1 = atoi(ptr); while(*ptr != '-') ptr++;
		     ptr++;
		     n2 = atoi(ptr);
		  }
	       } else if(i + 2 < ncol && yyvsp[0].t_list->i_list[i + 2]->str[0] == '-') {
		  n1 = atoi(yyvsp[0].t_list->i_list[i + 1]->str);
		  n2 = atoi(yyvsp[0].t_list->i_list[i + 2]->str + 1);
		  extra = 1;		/* we parsed an extra field */
	       } else {
		  n1 = n2 = atoi(yyvsp[0].t_list->i_list[i + 1]->str);
	       }
	       
	       for(k = n1;k <= n2;k++) {
		  if(j >= size_cols) {	/* we need more space */
		     int l;
		     
		     if(sm_verbose > 2) {
			msg("Reallocating space in READ { ... }\n");
		     }
		     size_cols += 10;
		     if((cols = (int *)realloc((char *)cols,
					     size_cols*sizeof(int))) == NULL) {
			msg("Can't allocate space for columns list\n");
			free((char *)temp_s); free((char *)temp);
			break;
		     }
		     if((temp_s = (VECTOR *)realloc((char *)temp_s,
			   		  size_cols*sizeof(VECTOR))) == NULL) {
			msg("Can't reallocate storage for temp_s\n");
			free((char *)temp);
			free((char *)cols);
			cols = NULL;
			break;
		     }
		     free((char *)temp);
		     if((temp = (VECTOR **)malloc(size_cols*sizeof(VECTOR *)))
								     == NULL) {
			msg("Can't reallocate storage for temp\n");
			free((char *)cols);
			free((char *)temp_s);
			cols = NULL;
			break;
		     }
		     for(l = 0;l < size_cols;l++) {
			temp[l] = temp_s + l;
			temp[l]->name = temp[l]->descrip + 1;
		     }
		  }

		  temp[j]->type = parse_qualifier(yyvsp[0].t_list->i_list[i + 1]->str);
		  if(n1 == n2) {
		     sprintf(temp[j]->descrip,"\001%s",yyvsp[0].t_list->i_list[i]->str);
		  } else {
		     if(temp[j]->type != VEC_FLOAT) {
			msg_1s("Multi-column vectors must be numeric (%s)\n",
			       yyvsp[0].t_list->i_list[i]->str);
			continue;
		     }
		     if(k == n1) {
			sprintf(temp[j]->descrip,"\001+%s",yyvsp[0].t_list->i_list[i]->str);
		     } else {
			sprintf(temp[j]->descrip,"\001|%s%d",
				yyvsp[0].t_list->i_list[i]->str,k - n1);
		     }
		  }
		  cols[j++] = k;
	       }
	       if(cols == NULL) {	/* realloc failed */
		  break;
	       }
	    }
	    freelist(yyvsp[0].t_list);
	    if(cols == NULL) {		/* realloc failed */
	       break;
	    }

	    nvec = read_column(yyvsp[-1].intval,data_file,cols,temp,j,line_1,line_2,"");
	    free((char *)cols);

	    for(i = 0;i < nvec;i++) {
	       if(*temp[i]->name != '+') {
		  copy_vector(temp[i]->name,*temp[i]);
	       } else {
		  int nmerge;
		  VECTOR merged;

		  for(j = i + 1;j < nvec && *temp[j]->name == '|';j++)continue;
		  nmerge = j - i;
		  merged.type = temp[i]->type;
		  
		  if(vec_malloc(&merged,nmerge*temp[i]->dimen) != 0) {
		     msg_1s("Can't get space for %s\n",temp[i]->name + 1);
		  } else {
		     for(j = 0;j < nmerge;j++) {
			for(k = 0;k < temp[i]->dimen;k++) {
			   merged.vec.f[j + nmerge*k] = temp[i + j]->vec.f[k];
			}
		     }
		     copy_vector(temp[i]->name + 1,merged);
		  }
		  
		  vec_free(temp[i++]);
		  while(i < nvec && *temp[i]->name == '|') {
		     vec_free(temp[i]);
		  }
	       }
	    }
	    free((char *)temp_s);
	    free((char *)temp);
	 ;
    break;}
case 84:
/* #line 906 "control.y" */
{
	    int i,cols[1],nvec;
	    VECTOR **vecs, *s_vecs;

	    yyvsp[-2].intval = (yyvsp[-2].intval == '!') ? 1 : 0;
	    if(yyvsp[0].t_list == NULL) break;

	    if((vecs = (VECTOR **)malloc(yyvsp[0].t_list->nitem*sizeof(VECTOR *)))== NULL ||
	       (s_vecs = (VECTOR *)malloc(yyvsp[0].t_list->nitem*sizeof(VECTOR))) == NULL) {
	       msg("Can't allocate storage for vecs in READ string { ... }\n");
	       if(vecs != NULL) free((char *)vecs);
	       freelist(yyvsp[0].t_list);
	       break;
	    }
	    nvec = 0;
	    for(i = 0;i < yyvsp[0].t_list->nitem;i++) {
	       if(isdigit(yyvsp[0].t_list->i_list[i]->str[0])) {
		  msg_1s("%s isn't a valid name for a vector\n",yyvsp[0].t_list->i_list[i]->str);
		  continue;
	       }
	       vecs[nvec] = s_vecs + nvec;
	       vecs[nvec++]->name = yyvsp[0].t_list->i_list[i]->str; /* type will come from fmt*/
	    }
	    cols[0] = 1;		/* don't just print data */
	    nvec = read_column(yyvsp[-2].intval,data_file,cols,vecs,nvec,line_1,line_2,yyvsp[-1].charval);

	    for(i = 0;i < nvec;i++) {
	       copy_vector(vecs[i]->name,*vecs[i]);
	    }
	    free((char *)vecs); free((char *)s_vecs);
            freelist(yyvsp[0].t_list);
	 ;
    break;}
case 85:
/* #line 939 "control.y" */
{
	    int i, j;
	    int nvec;			/* number of vector's names */
	    int nextra;			/* number of extra vectors implied
					   by names like sky[0-3] */
	    VECTOR **vecs, *s_vecs;

	    if(yyvsp[0].t_list == NULL) break;

	    nextra = nvec = 0;
	    if(strcmp(yyvsp[-1].charval,"bycolumn") == 0) { /* a list of WORD id ... */
	       for(i = 0;i < yyvsp[0].t_list->nitem - 1;i += 2) {
		  if(isdigit(yyvsp[0].t_list->i_list[i]->str[0])) {
		     msg_1s("%s isn't a valid name for a vector\n",
			    yyvsp[0].t_list->i_list[i]->str);
		  } else {
		     nvec++;
		  }
	       }
	       if(i != yyvsp[0].t_list->nitem) {
		  msg_1s("Ignoring junk at end of READ TABLE list: %s\n",
			 yyvsp[0].t_list->i_list[yyvsp[0].t_list->nitem - 1]->str);
	       }
	    } else {
	       for(i = 0;i < yyvsp[0].t_list->nitem;i++) {
		  if(isdigit(yyvsp[0].t_list->i_list[i]->str[0])) {
		     msg_1s("%s isn't a valid name for a vector\n",
								yyvsp[0].t_list->i_list[i]->str);
		  } else {
		     char *val0;	/* pointer to "0" in "name[0-1]" */
		     char *val1;	/* pointer to "1" in "name[0-1]" */
		     if((val0 = strchr(yyvsp[0].t_list->i_list[i]->str,'[')) != NULL) {
			val1 = ++val0;
			if(*val1 == '-') val1++;
			while(isdigit(*val1)) val1++;
			if(*val1 == '-') {
			   val1++;
			   if(isdigit(*val1)) {	/* OK, a range */
			      int n = atoi(val1) - atoi(val0);
			      if(n < 0 || nextra > 100) {
				 msg_1d("I don't believe that you want %d",
								   n + 1);
				 msg_1s(" vectors from %s\n",yyvsp[0].t_list->i_list[i]->str);
			      } else {
				 nextra += n;
			      }
			   }
			}
		     }
		     nvec++;
		  }
	       }
	    }

	    if((vecs = (VECTOR **)malloc((nvec + nextra)*sizeof(VECTOR *))) ==
									NULL ||
	       (s_vecs = (VECTOR *)malloc((nvec + nextra)*sizeof(VECTOR))) ==
									NULL) {
	       msg("Can't allocate storage for vecs in READ TABLE {...}\n");
	       if(vecs != NULL) free((char *)vecs);
	       freelist(yyvsp[0].t_list);
	       break;
	    }
	    for(j = 0;j < nvec + nextra;j++) {
	       vecs[j] = s_vecs + j;
	       vecs[j]->name = vecs[j]->descrip; /* use descrip as scratch */
	       *vecs[j]->name = '\0';
	    }
	    
	    if(strcmp(yyvsp[-1].charval,"bycolumn") == 0) { /* a list of WORD id ... */
	       for(i = j = 0;i < yyvsp[0].t_list->nitem - 1;i += 2) {
		  if(isdigit(yyvsp[0].t_list->i_list[i]->str[0])) {
		     continue;
		  }
		  vecs[j]->type = 0;	/* real type will come from table */
		  strncpy(vecs[j]->descrip,yyvsp[0].t_list->i_list[i]->str,VEC_DESCRIP_SIZE);
		  j++;
	       }
	    } else {
	       for(i = j = 0;i < yyvsp[0].t_list->nitem;i++) {
		  if(isdigit(yyvsp[0].t_list->i_list[i]->str[0])) { /* we already warned them */
		     continue;
		  }
		  vecs[j]->type = 0;	/* real type will come from table */
		  strncpy(vecs[j]->descrip,yyvsp[0].t_list->i_list[i]->str,VEC_DESCRIP_SIZE);
		  j++;
	       }
	    }

	    nvec = read_table(data_file, subtable, vecs, nvec, nextra,
			      line_1, line_2, yyvsp[-1].charval, table_fmt);
	    for(i = 0;i < nvec;i++) {
	       copy_vector(vecs[i]->name, *vecs[i]);
	    }

	    free((char *)vecs); free((char *)s_vecs);
            freelist(yyvsp[0].t_list);
	 ;
    break;}
case 86:
/* #line 1038 "control.y" */
{ restore(yyvsp[0].charval); ;
    break;}
case 87:
/* #line 1040 "control.y" */
{ mac_return(); ;
    break;}
case 88:
/* #line 1042 "control.y" */
{ save(yyvsp[0].charval,0); ;
    break;}
case 89:
/* #line 1044 "control.y" */
{
	    int dimension,i;
	    VECTOR *temp;

	    dimension = (int)(atof(yyvsp[0].charval) + 0.5);
	    i = parse_qualifier(yyvsp[0].charval);
	    if((temp = make_vector(yyvsp[-3].charval,dimension,i)) != NULL) {
	       if(temp->type == VEC_FLOAT) {
		  for(i = 0;i < dimension;i++) {
		     temp->vec.f[i] = 0;
		  }
	       } else {
		  for(i = 0;i < dimension;i++) {
		     temp->vec.s.s[i][0] = '\0';
		  }
	       }
	    }
	 ;
    break;}
case 90:
/* #line 1063 "control.y" */
{
	    if(*mgets(word,CHARMAX) != '\0') {
	       set_help_vector(yyvsp[0].charval,&word[1]);
	    }
	 ;
    break;}
case 91:
/* #line 1069 "control.y" */
{
	    if(sm_verbose) {
	       msg("\"set image(expr,expr) = expr\" is obsolete; ");
	       msg("please say \"image[expr,expr]\"\n");
	    }
	    vec_set_image_from_index(&yyvsp[-5].vector,&yyvsp[-3].vector,&yyvsp[0].vector);
	 ;
    break;}
case 92:
/* #line 1077 "control.y" */
{ vec_set_image_from_index(&yyvsp[-5].vector,&yyvsp[-3].vector,&yyvsp[0].vector); ;
    break;}
case 93:
/* #line 1079 "control.y" */
{ vec_set_image_from_index(NULL,&yyvsp[-3].vector,&yyvsp[0].vector); ;
    break;}
case 94:
/* #line 1081 "control.y" */
{ vec_set_image_from_index(&yyvsp[-5].vector,NULL,&yyvsp[0].vector); ;
    break;}
case 95:
/* #line 1083 "control.y" */
{ vec_set_image_from_index(NULL,NULL,&yyvsp[0].vector); ;
    break;}
case 96:
/* #line 1085 "control.y" */
{ set_random((long)yyvsp[0].floatval); ;
    break;}
case 97:
/* #line 1087 "control.y" */
{ make_local_vector(yyvsp[-1].charval); ;
    break;}
case 98:
/* #line 1089 "control.y" */
{ (void)copy_vector(yyvsp[-2].charval,yyvsp[0].vector); ;
    break;}
case 99:
/* #line 1090 "control.y" */
{ make_local_vector(yyvsp[0].charval); ;
    break;}
case 100:
/* #line 1091 "control.y" */
{ (void)copy_vector(yyvsp[-3].charval,yyvsp[0].vector); ;
    break;}
case 101:
/* #line 1093 "control.y" */
{
	    VECTOR *x;

	    if((x = get_vector_ptr(yyvsp[-5].charval)) == NULL) {
	       vec_free(&yyvsp[-3].vector); vec_free(&yyvsp[0].vector);
	       break;
	    }
	    vec_subscript(x,&yyvsp[-3].vector,&yyvsp[0].vector);
	 ;
    break;}
case 102:
/* #line 1103 "control.y" */
{
	    int c;
	    
	    if((c = input()) != ' ') unput(c);
	    if(sm_verbose > 3) msg("Just the place for a snark!\n");
	    if(recurse_lvl == 0) {
	       break;
	    }
	    if(sm_interrupt && recurse_lvl > 1) {	/* keep on popping */
	       int save_interrupt = sm_interrupt;
	       sm_interrupt = 0;
	       start_line();		/* start a new line in tokens.c */
	       push("SNARK ",S_TEMP);
	       sm_interrupt = save_interrupt;
	    }
	    recurse_lvl--;
	    return(1);
	 ;
    break;}
case 103:
/* #line 1122 "control.y" */
{
	    int dimen = 0,
	    	i,k,nvec,
	        n_float = 0,		/* number of float vectors */
	        n_string = 0,		/* number of string vectors */
		*sorted;		/* sorted indices */
	    VECTOR *temp[10];
	    VECTOR temp_f,temp_s;	/* temp vectors for rearranging */

	    if((nvec = yyvsp[0].t_list->nitem) > 10) {
	       msg("Sorry, I can only sort 10 vectors\n");
	       nvec = 10;
	    } else if(nvec == 0) {
	       freelist(yyvsp[0].t_list);
	    }

	    for(i = 0;i < nvec && !sm_interrupt;i++) {	/* get vectors */
	       if((temp[i] = get_vector_ptr(yyvsp[0].t_list->i_list[i]->str)) == NULL) {
		  break;
	       }
	       if(temp[i]->type == VEC_FLOAT) {
		  n_float++;
	       } else if(temp[i]->type == VEC_STRING) {
		  n_string++;
	       } else {
		  msg_1d("Unknown vector type: %d",temp[i]->type);
		  msg_1s(" for vector %s\n",temp[i]->name);
	       }
	       if(i == 0) {
		  dimen = temp[0]->dimen;
	       } else if(temp[i]->dimen != dimen) {
		  msg("Vectors are different sizes\n");
		  break;
	       }
	    }
            freelist(yyvsp[0].t_list);
	    if(i < nvec) {
	       break;
	    }

	    if((sorted = (int *)malloc((unsigned)dimen*sizeof(int))) == NULL) {
	       msg("malloc returns NULL for SORT\n");
	       break;
	    }
	    if(n_float > 0) {
	       temp_f.type = VEC_FLOAT;
	       if(vec_malloc(&temp_f,dimen) == -1) {
		  msg("malloc returns NULL for SORT\n");
		  free((char *)sorted);
		  break;
	       }
	    }
	    if(n_string > 0) {
	       temp_s.type = VEC_STRING;
	       if(vec_malloc(&temp_s,dimen) == -1) {
		  msg("malloc returns NULL for SORT\n");
		  free((char *)sorted);
		  vec_free(&temp_f);
		  break;
	       }
	    }
	    if(temp[0]->type == VEC_FLOAT) {
	       sort_flt_inds(temp[0]->vec.f,sorted,dimen);
	    } else if(temp[0]->type == VEC_STRING) {
	       sort_str_inds(temp[0]->vec.s.s,sorted,dimen);
	    } else {
	       msg("You can't get here. SORT.\n");
	    }

	    for(k = 0;!sm_interrupt && k < nvec;k++) {	/* for each vector */
	       if(temp[k]->type == VEC_FLOAT) {
		  (void)memcpy((Void *)temp_f.vec.f,
			     (Const Void *)temp[k]->vec.f,dimen*sizeof(REAL));

		  for(i = 0;i < dimen;i++) {		/* restore it sorted */
		     temp[k]->vec.f[i] = temp_f.vec.f[sorted[i]];
		  }
	       } else {
		  (void)memcpy((Void *)temp_s.vec.s.s_s,
			  (Const Void *)temp[k]->vec.s.s_s,dimen*VEC_STR_SIZE);

		  for(i = 0;i < dimen;i++) {		/* restore it sorted */
		     strcpy(temp[k]->vec.s.s[i],temp_s.vec.s.s[sorted[i]]);
		  }
	       }
	    }

	    free((char *)sorted);
	    if(n_float > 0) vec_free(&temp_f);
	    if(n_string > 0) vec_free(&temp_s);
	 ;
    break;}
case 104:
/* #line 1214 "control.y" */
{ (void)spline(yyvsp[-3].charval,yyvsp[-2].charval,yyvsp[-1].charval,yyvsp[0].charval); ;
    break;}
case 105:
/* #line 1216 "control.y" */
{
	    FILE *fil;

	    if((fil = fopen(yyvsp[0].charval,"r")) == NULL) {
	       msg_1s("Can't open %s\n",yyvsp[0].charval);
	    } else {
	       (void)fclose(fil);
	       read_table_header(yyvsp[0].charval,yyvsp[-2].intval);
	    }
	    (void)strncpy(data_file,yyvsp[0].charval,CHARMAX); /* the file to read data */
	    (void)strncpy(table_fmt,yyvsp[-1].charval,CHARMAX);

	    line_1 = line_2 = 0;	/* no lines specified */
	    set_data_file(yyvsp[0].charval);

	    subtable = yyvsp[-2].intval;
	 ;
    break;}
case 106:
/* #line 1234 "control.y" */
{ sm_ticksize( yyvsp[-3].floatval, yyvsp[-2].floatval, yyvsp[-1].floatval, yyvsp[0].floatval); ;
    break;}
case 107:
/* #line 1236 "control.y" */
{ (void)set_term_type(yyvsp[-1].charval,yyvsp[0].intval); ;
    break;}
case 108:
/* #line 1238 "control.y" */
{
	    static int abort_depth = 0;	/* depth of nesting abort handlers */
	    char *ptr;
	    if((ptr = mgets(word,CHARMAX)) == NULL || *ptr == '\0') {
	       ptr = "USER ABORT";
	    } else {
	       ptr++;			/* skip initial space */
	    }

	    if(abort_depth++ == 100) {
	       msg("abort handler depth too great (100 max)\n");
	       abort_depth = 0;
	       start_line();

	       msg_1s("%s\n",ptr);
	       save_str("<user abort>");
	       YYERROR;
	    }

	    if(get_macro("abort_handler",
			 (int *)NULL,(int *)NULL,(int *)NULL) != NULL) {
	       push("\n",S_NORMAL);
	       push(ptr,S_NORMAL);
	       push("abort_handler ",S_NORMAL);
	       if(sm_verbose > 2) {
		  msg_1s(">> macro : abort_handler %s\n",ptr);
	       }
	       (void)yyparse();
	       push("\n",S_NORMAL);
	    } else {
	       start_line();
	       msg_1s("%s\n",ptr);
	       save_str("<user abort>");
	       YYERROR;
	    }
	 ;
    break;}
case 109:
/* #line 1275 "control.y" */
{
	     word[1] = '\0';
	     if(mgets(word,CHARMAX) != NULL) {
	        userfn(&yyvsp[0].intval,&word[1]);
	     }
	  ;
    break;}
case 110:
/* #line 1282 "control.y" */
{
	    if(yyvsp[0].floatval < 0) {
#if defined(YYDEBUG)
	       yydebug = 1 - yydebug;	/* toggle yydebug */
#endif
	       yyvsp[0].floatval = -yyvsp[0].floatval;
	    }
	    sm_verbose = yyvsp[0].floatval;
	 ;
    break;}
case 111:
/* #line 1292 "control.y" */
{ sm_set_viewpoint(yyvsp[-2].floatval,yyvsp[-1].floatval,yyvsp[0].floatval); ;
    break;}
case 112:
/* #line 1294 "control.y" */
{
	    char *cmd;
	    char *fmt = "IF(%s) { %s } ELSE { BREAK }\n ";
	    int len2, len4;

	    len2 = strlen(yyvsp[-3].strval.start); yyvsp[-3].strval.start[len2 - 1] = '\0'; len2--;
	    len4 = strlen(yyvsp[-1].strval.start); yyvsp[-1].strval.start[len4 - 1] = '\0'; len4--;

	    if((cmd = malloc(len2 + len4 + (strlen(fmt) - 4) + 1)) == NULL) {
	       msg("Can't allocate space for while loop\n");
	       free((char *)yyvsp[-3].strval.start); free((char *)yyvsp[-1].strval.start);
	       break;
	    }

	    sprintf(cmd,fmt,yyvsp[-3].strval.start,yyvsp[-1].strval.start);
	    push(cmd,S_WHILE);

	    free((char *)yyvsp[-3].strval.start); free((char *)yyvsp[-1].strval.start);
	 ;
    break;}
case 113:
/* #line 1314 "control.y" */
{ end_while(); ;
    break;}
case 114:
/* #line 1316 "control.y" */
{ sm_window( yyvsp[-3].intval, yyvsp[-2].intval, yyvsp[-1].intval, yyvsp[0].intval, yyvsp[-1].intval, yyvsp[0].intval); ;
    break;}
case 115:
/* #line 1318 "control.y" */
{ sm_window( yyvsp[-5].intval, yyvsp[-4].intval, yyvsp[-3].intval, yyvsp[-2].intval, yyvsp[-3].intval, yyvsp[0].intval); ;
    break;}
case 116:
/* #line 1320 "control.y" */
{ sm_window( yyvsp[-5].intval, yyvsp[-4].intval, yyvsp[-3].intval, yyvsp[0].intval, yyvsp[-1].intval, yyvsp[0].intval); ;
    break;}
case 117:
/* #line 1322 "control.y" */
{ sm_window( yyvsp[-7].intval, yyvsp[-6].intval, yyvsp[-5].intval, yyvsp[-2].intval, yyvsp[-3].intval, yyvsp[0].intval); ;
    break;}
case 118:
/* #line 1324 "control.y" */
{
            if(execute(yyvsp[0].charval) == 0) {	/* it's a macro */
	       start_line();		/* start a new line in tokens.c */
	       if(sm_verbose > 2) msg_1s(">> macro : %s\n",yyvsp[0].charval);
	    } else {
	       if(!strcmp(yyvsp[0].charval,"\n")) {	/* probably in quotes by mistake */
		  msg("\"\\n\" is not a valid macro\n");
		  in_quote = noexpand = 0;
		  YYERROR;
	       } else {
		  if(get_macro("macro_error_handler",
			       (int *)NULL,(int *)NULL,(int *)NULL) == NULL) {
		     msg_1s("%s is not a macro\n",yyvsp[0].charval);
		  } else {
		     static char name[60];
		     strcpy(name,yyvsp[0].charval);
		     noexpand = 0;	/* we must be able to recognise the
					   error handler */
		     push(name,S_NORMAL);
		     push("macro_error_handler NOT_FOUND ",S_NORMAL);
		     if(sm_verbose > 2) {
			msg_1s(">> WORD : %s\n",name);
			msg(">> macro : macro_error_handler NOT_FOUND\n");
		     }
		     (void)yyparse();
		     push("\n",S_NORMAL);
		  }
	       }
	       break;
	    }
         ;
    break;}
case 119:
/* #line 1356 "control.y" */
{ (void)read_history_macro(yyvsp[0].charval); ;
    break;}
case 120:
/* #line 1358 "control.y" */
{
	    (void)mgets(buff,MACROSIZE);
	    msg_1s("%s\n",&buff[*buff == '\0' ? 0 : 1]); /* skip ' ' */
         ;
    break;}
case 121:
/* #line 1363 "control.y" */
{
	    static char file[80] = "";	/* name of file */
	    FILE *fil;

	    (void)mgets(buff,MACROSIZE);
	    if(yyvsp[-1].intval == '+') {		/* treat file as old and append */
	       (void)strcpy(file,yyvsp[0].charval);
	    }
	    if(strcmp(file,yyvsp[0].charval) == 0) {	/* append to old file */
	       if((fil = fopen(file,"a")) == NULL) {
		  msg_1s("Can't reopen %s\n",file);
		  break;
	       }
	    } else {
	       if((fil = fopen(yyvsp[0].charval,"w")) == NULL) {
		  fprintf(stderr,"Can't open %s\n",yyvsp[0].charval);
		  break;
	       }
	       (void)strcpy(file,yyvsp[0].charval);
	    }
	    fprintf(fil,"%s\n",&buff[*buff == '\0' ? 0 : 1]);	/* skip ' ' */
	    fclose(fil);
         ;
    break;}
case 122:
/* #line 1389 "control.y" */
{
	    if((yyval.t_list = getlist((TOK_LIST *)NULL)) == NULL) {
	       break;
	    }
	 ;
    break;}
case 123:
/* #line 1395 "control.y" */
{
	    if((yyval.t_list = getlist((TOK_LIST *)NULL)) == NULL) {
	       break;
	    }

	    yyval.t_list->i_type[yyval.t_list->nitem] = TYPE_WORD;
	    (void)strncpy(yyval.t_list->i_list[yyval.t_list->nitem++]->str,yyvsp[0].charval,CHARMAX);
	 ;
    break;}
case 124:
/* #line 1404 "control.y" */
{
	    if(yyvsp[-2].t_list == NULL) {		/* couldn't get space */
	       yyval.t_list = NULL;
	       break;
	    }
            if(yyvsp[-2].t_list->nitem >= yyvsp[-2].t_list->nmax) {	/* get some more space */
	       yyval.t_list = getlist(yyvsp[-2].t_list);
	    } else {
	       yyval.t_list = yyvsp[-2].t_list;
	    }

	    yyval.t_list->i_type[yyval.t_list->nitem] = TYPE_WORD;
	    (void)strncpy(yyval.t_list->i_list[yyval.t_list->nitem++]->str,yyvsp[0].charval,CHARMAX);
	 ;
    break;}
case 125:
/* #line 1419 "control.y" */
{
	    if((yyval.t_list = getlist((TOK_LIST *)NULL)) == NULL) {
	       break;
	    }

	    yyval.t_list->i_type[yyval.t_list->nitem] = TYPE_VECTOR;
	    yyval.t_list->i_list[yyval.t_list->nitem++]->vec = yyvsp[0].vector;
	 ;
    break;}
case 126:
/* #line 1428 "control.y" */
{
	    if(yyvsp[-2].t_list == NULL) {		/* couldn't get space */
	       yyval.t_list = NULL;
	       break;
	    }
            if(yyvsp[-2].t_list->nitem >= yyvsp[-2].t_list->nmax) {	/* get some more space */
	       yyval.t_list = getlist(yyvsp[-2].t_list);
	    } else {
	       yyval.t_list = yyvsp[-2].t_list;
	    }

	    yyval.t_list->i_type[yyval.t_list->nitem] = TYPE_VECTOR;
	    yyval.t_list->i_list[yyval.t_list->nitem++]->vec = yyvsp[0].vector;
	 ;
    break;}
case 127:
/* #line 1445 "control.y" */
{
	    int i,j,
	        type;			/* type of vector */

	    if(yyvsp[0].t_list == NULL) break;
	    if(num_or_word(yyvsp[0].t_list->i_list[0]->str) == 0) {
	       type = VEC_STRING;
	    } else {
	       type = VEC_FLOAT;
	    }
	    if(make_anon_vector(&yyval.vector,yyvsp[0].t_list->nitem,type) != 0) {
	       yyval.vector.type = VEC_NULL;
	       j = 0;
	    } else {
	       for(i = j = 0;i < yyvsp[0].t_list->nitem;i++) {
		  if(yyvsp[0].t_list->i_list[i]->str[0] == '\n' && yyvsp[0].t_list->i_list[i]->str[1] == '\0') {
		     continue;			/* skip \n */
		  }
		  if(type == VEC_FLOAT) {
		     yyval.vector.vec.f[j++] = atof2(yyvsp[0].t_list->i_list[i]->str);
		  } else {
		     (void)strncpy(yyval.vector.vec.s.s[j++],yyvsp[0].t_list->i_list[i]->str,VEC_STR_SIZE);
		  }
	       }
	    }
	    yyval.vector.dimen = j;		/* don't bother to realloc storage */
            freelist(yyvsp[0].t_list);
	 ;
    break;}
case 128:
/* #line 1474 "control.y" */
{ vec_concat(&yyvsp[-2].vector,&yyvsp[0].vector,&yyval.vector); ;
    break;}
case 129:
/* #line 1476 "control.y" */
{
	    if(yyvsp[0].charval[0] == '0') {		/* may be a hex or octal constant */
	       REAL val;
	       if((val = atof2(yyvsp[0].charval)) == 0) {
		  if(!strcmp(yyvsp[0].charval,"0x0")) { /* the only non-word == 0 */
		     ;
		  } else {
		     msg_1s("Illegal vector name: %s\n",yyvsp[0].charval);
		     break;
		  }
	       }
	       (void)vec_value(&yyval.vector,val);
	    } else if(get_vector(yyvsp[0].charval,&yyval.vector) < 0) {
	       break;
	    }
	 ;
    break;}
case 130:
/* #line 1493 "control.y" */
{
	    if(make_anon_vector(&yyval.vector,1,VEC_STRING) == 0) {
	       (void)strncpy(yyval.vector.vec.s.s[0],yyvsp[0].charval,VEC_STR_SIZE);
	    } else {
	       yyval.vector.type = VEC_NULL;
	    }
	 ;
    break;}
case 131:
/* #line 1501 "control.y" */
{
	    char *mtext;		/* body of macro */
	    int i,narg_min,narg_max;
	    VECTOR tmp;

	    if((mtext = get_macro(yyvsp[-3].charval,&narg_min,&narg_max,(int *)NULL)) ==
									NULL) {
	       msg_1s("Macro %s is not defined\n",yyvsp[-3].charval);
	       yyval.vector.type = VEC_NULL;
	       yyval.vector.name = "(undefined())";
	       yyval.vector.dimen = 0;
	       freelist(yyvsp[-1].t_list);
	       break;
	    } else if(yyvsp[-1].t_list->nitem < narg_min || yyvsp[-1].t_list->nitem > narg_max) {
	       msg_1s("Macro %s expects ",yyvsp[-3].charval);
	       msg_1d("%d <= narg <= ",narg_min);
	       msg_1d("%d, ",narg_max);
	       msg_1d("%d provided\n",i);
	       yyval.vector.type = VEC_NULL; yyval.vector.dimen = 0;
	       yyval.vector.name = "(macro())";
	       freelist(yyvsp[-1].t_list);
	       break;
	    }

	    push("\nSNARK",S_NORMAL);
	    push_mstack(yyvsp[-3].charval,0,0,0);
	    
	    for(i = 0;i < yyvsp[-1].t_list->nitem;i++) {
	       if(yyvsp[-1].t_list->i_type[i] == TYPE_WORD) {
		  if(strncmp(yyvsp[-1].t_list->i_list[i]->str,"__",2) == 0 &&
					 get_vector(yyvsp[-1].t_list->i_list[i]->str,&tmp) >= 0) {
		     sprintf(buff,"__%s_arg%d",yyvsp[-3].charval, i + 1);
		     make_local_vector(buff);
		     (void)copy_vector(buff,tmp);
		     add_marg(i + 1,buff);
		  } else {
		     add_marg(i + 1,yyvsp[-1].t_list->i_list[i]->str);
		  }
	       } else if(yyvsp[-1].t_list->i_type[i] == TYPE_VECTOR) {
		  sprintf(buff,"__%s_arg%d",yyvsp[-3].charval, i + 1);
		  make_local_vector(buff);
		  (void)copy_vector(buff,yyvsp[-1].t_list->i_list[i]->vec);
		  add_marg(i + 1,buff);
	       } else {
		  msg_1d("Unknown type on t_list: %d\n",yyvsp[-1].t_list->i_type[i]);
		  add_marg(i + 1,"unknown");
	       }
	    }
	    freelist(yyvsp[-1].t_list);
	    
	    recurse_lvl++;
	    push(mtext,S_MACRO);
	    yyparse();			/* execute macro _now_ */
	    get_vector(yyvsp[-3].charval,&yyval.vector);
	    free_vector(yyvsp[-3].charval);
	 ;
    break;}
case 132:
/* #line 1558 "control.y" */
{
	    int i,j;
	    VECTOR *temp;

	    if(yyvsp[-1].vector.type == VEC_STRING) {
	       msg_1s("Vector %s is not arithmetic\n",yyvsp[-1].vector.name);
	       yyval.vector.type = VEC_NULL;
	       yyval.vector.name = "(undefined[])";
	       yyval.vector.dimen = 0;
	       vec_free(&yyvsp[-1].vector);
	       break;
	    }
	    if((temp = get_vector_ptr(yyvsp[-3].charval)) == NULL ||
			make_anon_vector(&yyval.vector,yyvsp[-1].vector.dimen,temp->type) != 0) {
	       yyval.vector.type = VEC_NULL;
	       yyval.vector.name = "(undefined[])";
	       yyval.vector.dimen = 0;
	       vec_free(&yyvsp[-1].vector);
	       break;
	    }

	    for(j = 0;j < yyvsp[-1].vector.dimen;j++) {
	       i = (int)yyvsp[-1].vector.vec.f[j];
	       if(i >= 0 && i < temp->dimen) {
		  if(temp->type == VEC_FLOAT) {
		     yyval.vector.vec.f[j] = temp->vec.f[i];
		  } else {
		     strcpy(yyval.vector.vec.s.s[j],temp->vec.s.s[i]);
		  }
	       } else {
		  msg_1d("Subscript %d ",i);
		  msg_1s("for %s is out of range ",yyvsp[-3].charval);
		  msg_1d("[0,%d]\n",temp->dimen-1);
		  if(yyval.vector.type == VEC_STRING) {
		     yyval.vector.vec.s.s[j][0] = '\0';
		  } else if(yyval.vector.type == VEC_FLOAT) {
		     yyval.vector.vec.f[j] = 0;
		  }
	       }
	    }
	    vec_free(&yyvsp[-1].vector);
	 ;
    break;}
case 133:
/* #line 1601 "control.y" */
{ yyval.vector = yyvsp[-1].vector; ;
    break;}
case 134:
/* #line 1603 "control.y" */
{
	    VECTOR zero;		/* scalar with value 0 */

	    (void)vec_value(&zero,0.0);	/* set value of zero */
	    vec_subtract(&zero,&yyvsp[0].vector,&yyval.vector);
	 ;
    break;}
case 135:
/* #line 1610 "control.y" */
{ vec_ternary(&yyvsp[-4].vector,&yyvsp[-2].vector,&yyvsp[0].vector,&yyval.vector); ;
    break;}
case 136:
/* #line 1612 "control.y" */
{ vec_abs(&yyvsp[-1].vector,&yyval.vector); ;
    break;}
case 137:
/* #line 1614 "control.y" */
{ vec_acos(&yyvsp[-1].vector,&yyval.vector); ;
    break;}
case 138:
/* #line 1616 "control.y" */
{ vec_asin(&yyvsp[-1].vector,&yyval.vector); ;
    break;}
case 139:
/* #line 1618 "control.y" */
{ vec_atan(&yyvsp[-1].vector,&yyval.vector); ;
    break;}
case 140:
/* #line 1620 "control.y" */
{ vec_atan2(&yyvsp[-3].vector,&yyvsp[-1].vector,&yyval.vector); ;
    break;}
case 141:
/* #line 1622 "control.y" */
{ vec_cos(&yyvsp[-1].vector,&yyval.vector); ;
    break;}
case 142:
/* #line 1624 "control.y" */
{
	    yyval.vector.type = VEC_FLOAT;
	    vec_ctype(&yyval.vector);
	 ;
    break;}
case 143:
/* #line 1629 "control.y" */
{
	    yyval.vector.type = VEC_STRING;
	    vec_ctype(&yyval.vector);
	 ;
    break;}
case 144:
/* #line 1634 "control.y" */
{
	    if(make_anon_vector(&yyval.vector,0,VEC_NULL) != 0) {
	       break;
	    }
	    if(vec_do(&yyval.vector, yyvsp[-3].floatval, yyvsp[-1].floatval, 1) < 0) {
	       break;
	    }
	 ;
    break;}
case 145:
/* #line 1643 "control.y" */
{
	    if(make_anon_vector(&yyval.vector,0,VEC_NULL) != 0) {
	       break;
	    }
	    if(vec_do(&yyval.vector, yyvsp[-5].floatval, yyvsp[-3].floatval, yyvsp[-1].floatval) < 0) {
	       break;
	    }
	 ;
    break;}
case 146:
/* #line 1652 "control.y" */
{ vec_exp(&yyvsp[-1].vector,&yyval.vector); ;
    break;}
case 147:
/* #line 1654 "control.y" */
{ vec_add(&yyvsp[-2].vector,&yyvsp[0].vector,&yyval.vector); ;
    break;}
case 148:
/* #line 1656 "control.y" */
{ vec_subtract(&yyvsp[-2].vector,&yyvsp[0].vector,&yyval.vector); ;
    break;}
case 149:
/* #line 1658 "control.y" */
{ vec_multiply(&yyvsp[-2].vector,&yyvsp[0].vector,&yyval.vector); ;
    break;}
case 150:
/* #line 1660 "control.y" */
{ vec_divide(&yyvsp[-2].vector,&yyvsp[0].vector,&yyval.vector); ;
    break;}
case 151:
/* #line 1662 "control.y" */
{ vec_power(&yyvsp[-2].vector,&yyvsp[0].vector,&yyval.vector); ;
    break;}
case 152:
/* #line 1664 "control.y" */
{ vec_mod(&yyvsp[-2].vector,&yyvsp[0].vector,&yyval.vector); ;
    break;}
case 153:
/* #line 1666 "control.y" */
{ vec_bitand(&yyvsp[-2].vector,&yyvsp[0].vector,&yyval.vector); ;
    break;}
case 154:
/* #line 1668 "control.y" */
{ vec_bitor(&yyvsp[-2].vector,&yyvsp[0].vector,&yyval.vector); ;
    break;}
case 155:
/* #line 1670 "control.y" */
{ vec_eq(&yyvsp[-3].vector,&yyvsp[0].vector,&yyval.vector); ;
    break;}
case 156:
/* #line 1672 "control.y" */
{
	    VECTOR zero;		/* scalar with value 0 */

	    (void)vec_value(&zero,0.0);	/* set value of zero */
	    vec_eq(&zero,&yyvsp[0].vector,&yyval.vector);
	 ;
    break;}
case 157:
/* #line 1679 "control.y" */
{ vec_ne(&yyvsp[-3].vector,&yyvsp[0].vector,&yyval.vector); ;
    break;}
case 158:
/* #line 1681 "control.y" */
{ vec_and(&yyvsp[-3].vector,&yyvsp[0].vector,&yyval.vector); ;
    break;}
case 159:
/* #line 1683 "control.y" */
{ vec_or(&yyvsp[-3].vector,&yyvsp[0].vector,&yyval.vector); ;
    break;}
case 160:
/* #line 1685 "control.y" */
{ vec_gt(&yyvsp[-2].vector,&yyvsp[0].vector,&yyval.vector); ;
    break;}
case 161:
/* #line 1687 "control.y" */
{ vec_ge(&yyvsp[-3].vector,&yyvsp[0].vector,&yyval.vector); ;
    break;}
case 162:
/* #line 1689 "control.y" */
{ vec_gt(&yyvsp[0].vector,&yyvsp[-2].vector,&yyval.vector); ;
    break;}
case 163:
/* #line 1691 "control.y" */
{ vec_ge(&yyvsp[0].vector,&yyvsp[-3].vector,&yyval.vector); ;
    break;}
case 164:
/* #line 1693 "control.y" */
{ vec_float(&yyvsp[-1].vector,&yyval.vector); ;
    break;}
case 165:
/* #line 1695 "control.y" */
{ vec_gamma(&yyvsp[-3].vector,&yyvsp[-1].vector,&yyval.vector); ;
    break;}
case 166:
/* #line 1697 "control.y" */
{ vec_hist(&yyvsp[-3].vector,&yyvsp[-1].vector,&yyval.vector); ;
    break;}
case 167:
/* #line 1699 "control.y" */
{ vec_interp(&yyvsp[-3].vector,&yyvsp[-1].vector,&yyval.vector); ;
    break;}
case 168:
/* #line 1701 "control.y" */
{ vec_get_image_from_index(&yyvsp[-3].vector,&yyvsp[-1].vector,&yyval.vector); ;
    break;}
case 169:
/* #line 1703 "control.y" */
{ vec_get_image_from_index(NULL,&yyvsp[-1].vector,&yyval.vector); ;
    break;}
case 170:
/* #line 1705 "control.y" */
{ vec_get_image_from_index(&yyvsp[-3].vector,NULL,&yyval.vector); ;
    break;}
case 171:
/* #line 1707 "control.y" */
{ vec_get_image_from_index(NULL,NULL,&yyval.vector); ;
    break;}
case 172:
/* #line 1709 "control.y" */
{ vec_index(&yyvsp[-3].vector,&yyvsp[-1].vector,&yyval.vector); ;
    break;}
case 173:
/* #line 1711 "control.y" */
{ vec_int(&yyvsp[-1].vector,&yyval.vector); ;
    break;}
case 174:
/* #line 1713 "control.y" */
{ vec_length(&yyvsp[-1].vector,&yyval.vector); ;
    break;}
case 175:
/* #line 1715 "control.y" */
{ vec_lg(&yyvsp[-1].vector,&yyval.vector); ;
    break;}
case 176:
/* #line 1717 "control.y" */
{ vec_ln(&yyvsp[-1].vector,&yyval.vector); ;
    break;}
case 177:
/* #line 1719 "control.y" */
{ (void)vec_value(&yyval.vector,yyvsp[0].floatval); ;
    break;}
case 178:
/* #line 1721 "control.y" */
{ (void)vec_value(&yyval.vector,Pi); ;
    break;}
case 179:
/* #line 1723 "control.y" */
{ vec_random((int)yyvsp[-1].floatval,&yyval.vector); ;
    break;}
case 180:
/* #line 1725 "control.y" */
{ vec_sin(&yyvsp[-1].vector,&yyval.vector); ;
    break;}
case 181:
/* #line 1727 "control.y" */
{ vec_sprintf(&yyvsp[-3].vector,&yyvsp[-1].vector,&yyval.vector); ;
    break;}
case 182:
/* #line 1729 "control.y" */
{ vec_sqrt(&yyvsp[-1].vector,&yyval.vector); ;
    break;}
case 183:
/* #line 1731 "control.y" */
{ vec_string(&yyvsp[-1].vector,&yyval.vector); ;
    break;}
case 184:
/* #line 1733 "control.y" */
{ vec_strlen(&yyvsp[-1].vector,&yyval.vector); ;
    break;}
case 185:
/* #line 1735 "control.y" */
{ vec_substr(&yyvsp[-5].vector,&yyvsp[-3].vector,&yyvsp[-1].vector,&yyval.vector); ;
    break;}
case 186:
/* #line 1737 "control.y" */
{ vec_tan(&yyvsp[-1].vector,&yyval.vector); ;
    break;}
case 187:
/* #line 1741 "control.y" */
{ yyval.t_list = yyvsp[-1].t_list; ;
    break;}
case 188:
/* #line 1743 "control.y" */
{ yyval.t_list = yyvsp[-1].t_list; ;
    break;}
case 189:
/* #line 1747 "control.y" */
{ yyval.strval = yyvsp[-1].strval; ;
    break;}
case 190:
/* #line 1749 "control.y" */
{ yyval.strval = yyvsp[-1].strval; ;
    break;}
case 191:
/* #line 1753 "control.y" */
{ yyval.intval = 1; ;
    break;}
case 192:
/* #line 1755 "control.y" */
{ yyval.intval = 2; ;
    break;}
case 193:
/* #line 1759 "control.y" */
{ yyval.intval = '!'; ;
    break;}
case 194:
/* #line 1761 "control.y" */
{ yyval.intval =  ' '; ;
    break;}
case 195:
/* #line 1765 "control.y" */
{ yyval.t_list = yyvsp[-1].t_list; ;
    break;}
case 196:
/* #line 1767 "control.y" */
{ yyval.t_list = yyvsp[0].t_list; ;
    break;}
case 197:
/* #line 1769 "control.y" */
{
	    int i;
	    VECTOR *v;

	    if((yyval.t_list = getlist((TOK_LIST *)NULL)) == NULL) {
	       break;
	    }
	    
	    if((v = get_vector_ptr(yyvsp[0].charval)) == NULL) {
	       break;
	    }
	    if(v->type != VEC_FLOAT && v->type != VEC_STRING) {
	       msg_1s("Vector %s is neither arithmetic or string valued ",
		      v->name);
	       msg_1d("(it's %d)\n",v->type);
	       break;
	    }
	    
	    for(i = 0;i < v->dimen;i++) {
	       if(yyval.t_list->nitem >= yyval.t_list->nmax) { /* get some more space */
		  yyval.t_list = getlist(yyval.t_list);
	       }
	       
	       if(v->type == VEC_FLOAT) {
		  
		  sprintf(yyval.t_list->i_list[yyval.t_list->nitem++]->str,"%.10g",v->vec.f[i]);
	       } else if(v->type == VEC_STRING) {
		  (void)strncpy(yyval.t_list->i_list[yyval.t_list->nitem++]->str,v->vec.s.s[i],CHARMAX);
	       } else {
		  msg_1s("You cannot get here! (foreach %s ...)\n",v->name);
		  break;
	       }
	    }
	    if(i != v->dimen) { break; } /* error in loop */
	 ;
    break;}
case 198:
/* #line 1808 "control.y" */
{ (void)sm_axis( yyvsp[-8].floatval, yyvsp[-7].floatval, yyvsp[-6].floatval, yyvsp[-5].floatval, yyvsp[-4].intval, yyvsp[-3].intval, yyvsp[-2].intval, yyvsp[-1].intval, yyvsp[0].intval ); ;
    break;}
case 199:
/* #line 1810 "control.y" */
{ vec_axis( yyvsp[-8].floatval, yyvsp[-7].floatval, &yyvsp[-6].vector, &yyvsp[-5].vector, (VECTOR *)NULL, yyvsp[-4].intval, yyvsp[-3].intval, yyvsp[-2].intval, yyvsp[-1].intval, yyvsp[0].intval ); ;
    break;}
case 200:
/* #line 1813 "control.y" */
{
	    VECTOR *lab;
	    
	    if((lab = get_vector_ptr(yyvsp[-5].charval)) == NULL) {
	       break;
	    }
	    if(lab->type != VEC_STRING) {
	       msg_1s("Error: %s is not a string vector\n",yyvsp[-5].charval);
	       YYERROR;
	    }
	    if(lab->dimen != yyvsp[-6].vector.dimen && lab->dimen != 1) {
	       msg_2s("The dimensions of %s and %s must be the same\n",
		      yyvsp[-6].vector.name,yyvsp[-5].charval);
	       YYERROR;
	    }
	    vec_axis( yyvsp[-9].floatval, yyvsp[-8].floatval, &yyvsp[-7].vector, &yyvsp[-6].vector, lab, yyvsp[-4].intval, yyvsp[-3].intval, yyvsp[-2].intval, yyvsp[-1].intval, yyvsp[0].intval );
	 ;
    break;}
case 201:
/* #line 1831 "control.y" */
{ sm_box(1,2,0,0); ;
    break;}
case 202:
/* #line 1833 "control.y" */
{ sm_box(yyvsp[-1].intval,yyvsp[0].intval,0,0); ;
    break;}
case 203:
/* #line 1835 "control.y" */
{ sm_box(yyvsp[-3].intval,yyvsp[-2].intval,yyvsp[-1].intval,yyvsp[0].intval); ;
    break;}
case 204:
/* #line 1837 "control.y" */
{ (void)sm_contour(); ;
    break;}
case 205:
/* #line 1839 "control.y" */
{
	    set_color(&yyvsp[0].vector);
	    vec_free(&yyvsp[0].vector);
	 ;
    break;}
case 206:
/* #line 1844 "control.y" */
{ sm_ctype_i(yyvsp[0].intval); ;
    break;}
case 207:
/* #line 1846 "control.y" */
{ sm_ctype(yyvsp[0].charval); ;
    break;}
case 208:
/* #line 1848 "control.y" */
{ sm_dot(); ;
    break;}
case 209:
/* #line 1850 "control.y" */
{ sm_draw(yyvsp[-1].floatval,yyvsp[0].floatval); ;
    break;}
case 210:
/* #line 1852 "control.y" */
{ gdraw(yyvsp[-2].floatval,yyvsp[-1].floatval); ;
    break;}
case 211:
/* #line 1854 "control.y" */
{ (*devices[devnum].dev_erase)(); ;
    break;}
case 212:
/* #line 1856 "control.y" */
{
	    REAL *temp = NULL;
	    int i,npoint;

	     if(yyvsp[-3].vector.dimen < yyvsp[-2].vector.dimen) {
	        msg_2s("%s contains fewer points than %s\n",yyvsp[-3].vector.name,yyvsp[-2].vector.name);
	        npoint = yyvsp[-3].vector.dimen;
	     } else if(yyvsp[-2].vector.dimen < yyvsp[-3].vector.dimen) {
	        msg_2s("%s contains fewer points than %s\n",yyvsp[-2].vector.name,yyvsp[-3].vector.name);
	        npoint = yyvsp[-2].vector.dimen;
	     } else {
	        npoint = yyvsp[-3].vector.dimen;
	     }

	     if(yyvsp[-1].vector.dimen == 1) {
		if((temp = (REAL *)malloc((unsigned)npoint*sizeof(REAL)))
								== NULL) {
		   msg("Can't allocate space in errorbar\n");
		   vec_free(&yyvsp[-3].vector); vec_free(&yyvsp[-2].vector); vec_free(&yyvsp[-1].vector);
		   break;
		}
		for(i = 0;i < npoint;i++) {
		   temp[i] = yyvsp[-1].vector.vec.f[0];
		}
		free((char *)(yyvsp[-1].vector.vec.f));
		yyvsp[-1].vector.vec.f = temp;
	     } else if(yyvsp[-1].vector.dimen < npoint) {
		msg_2s("%s is smaller than %s ",yyvsp[-1].vector.name,yyvsp[-3].vector.name);
		msg_1s("or %s, truncating\n",yyvsp[-2].vector.name);
		npoint = yyvsp[-1].vector.dimen;
	     } else if(yyvsp[-1].vector.dimen > npoint) {
		msg_2s("%s is larger than %s ",yyvsp[-1].vector.name,yyvsp[-3].vector.name);
		msg_1s("or %s\n",yyvsp[-2].vector.name);
	     }

	     (void)sm_errorbar(yyvsp[-3].vector.vec.f,yyvsp[-2].vector.vec.f,yyvsp[-1].vector.vec.f,yyvsp[0].intval,npoint);
	     vec_free(&yyvsp[-3].vector); vec_free(&yyvsp[-2].vector); vec_free(&yyvsp[-1].vector);
	  ;
    break;}
case 213:
/* #line 1895 "control.y" */
{ sm_grid(yyvsp[-1].intval,yyvsp[0].intval); ;
    break;}
case 214:
/* #line 1897 "control.y" */
{
	    if(*mgets(buff,MACROSIZE) != '\0') {
	       sm_label(&buff[1]);
	    } else {
	       msg("Can't get label\n");
	    }
	 ;
    break;}
case 215:
/* #line 1905 "control.y" */
{ sm_ltype( (int)yyvsp[0].floatval ); ;
    break;}
case 216:
/* #line 1907 "control.y" */
{ sm_ltype( 10 ); ;
    break;}
case 217:
/* #line 1909 "control.y" */
{ (*devices[devnum].dev_page)(); ;
    break;}
case 218:
/* #line 1911 "control.y" */
{
	    int npoint;

	    if(yyvsp[-1].vector.dimen < yyvsp[0].vector.dimen) {
	       msg_2s("%s contains fewer points than %s\n",yyvsp[-1].vector.name,yyvsp[0].vector.name);
	       npoint = yyvsp[-1].vector.dimen;
	    } else if(yyvsp[0].vector.dimen < yyvsp[-1].vector.dimen) {	
	       msg_2s("%s contains fewer points than %s\n",yyvsp[0].vector.name,yyvsp[-1].vector.name);
	       npoint = yyvsp[0].vector.dimen;
	    } else {
	       npoint = yyvsp[-1].vector.dimen;
	    }

	    if(yyvsp[-2].intval == CONNECT) {
	       (void)sm_conn( yyvsp[-1].vector.vec.f, yyvsp[0].vector.vec.f, npoint );
	    } else if(yyvsp[-2].intval == HISTOGRAM) {
	       (void)sm_histogram( yyvsp[-1].vector.vec.f, yyvsp[0].vector.vec.f, npoint );
	    } else if(yyvsp[-2].intval == POINTS) {
	       sm_points( yyvsp[-1].vector.vec.f, yyvsp[0].vector.vec.f, npoint );
	    } else {
	       msg("Unknown plotting command\n");
	    }
	    vec_free(&yyvsp[-1].vector); vec_free(&yyvsp[0].vector);
	 ;
    break;}
case 219:
/* #line 1936 "control.y" */
{
	    int npoint;

	    if(yyvsp[-5].vector.dimen < yyvsp[-4].vector.dimen) {
	       msg_2s("%s contains fewer points than %s\n",yyvsp[-5].vector.name,yyvsp[-4].vector.name);
	       npoint = yyvsp[-5].vector.dimen;
	    } else if(yyvsp[-4].vector.dimen < yyvsp[-5].vector.dimen) {
	       msg_2s("%s contains fewer points than %s\n",yyvsp[-4].vector.name,yyvsp[-5].vector.name);
	       npoint = yyvsp[-4].vector.dimen;
	    } else {
	       npoint = yyvsp[-5].vector.dimen;
	    }

	    if(yyvsp[-1].vector.dimen != npoint) {
	       msg("Logical vector differs in length from data\n");
	       if(npoint > yyvsp[-1].vector.dimen) {
		  npoint = yyvsp[-1].vector.dimen;
	       }
	    }

	    if(yyvsp[-6].intval == CONNECT) {
	       (void)conn_if( yyvsp[-5].vector.vec.f, yyvsp[-4].vector.vec.f, yyvsp[-1].vector.vec.f, npoint );
	    } else if(yyvsp[-6].intval == HISTOGRAM) {
	       (void)histogram_if( yyvsp[-5].vector.vec.f, yyvsp[-4].vector.vec.f, yyvsp[-1].vector.vec.f, npoint );
	    } else if(yyvsp[-6].intval == POINTS) {
	       points_if( yyvsp[-5].vector.vec.f, yyvsp[-4].vector.vec.f, yyvsp[-1].vector.vec.f, npoint );
	    } else {
	       msg("Unknown plotting command\n");
	    }
	    vec_free(&yyvsp[-1].vector); vec_free(&yyvsp[-5].vector); vec_free(&yyvsp[-4].vector);
	 ;
    break;}
case 220:
/* #line 1968 "control.y" */
{
	    if(*mgets(buff,MACROSIZE) != '\0') {
	       sm_putlabel(yyvsp[0].intval,&buff[1]);
	    } else {
	       msg("Can't get label\n");
	    }
	  ;
    break;}
case 221:
/* #line 1976 "control.y" */
{ sm_relocate(yyvsp[-1].floatval,yyvsp[0].floatval); ;
    break;}
case 222:
/* #line 1978 "control.y" */
{ sm_grelocate(yyvsp[-2].floatval,yyvsp[-1].floatval); ;
    break;}
case 223:
/* #line 1980 "control.y" */
{
	    int npoint;

	    npoint = yyvsp[-1].vector.dimen;
	    if(npoint != yyvsp[0].vector.dimen) {
	       msg("dimension of vectors in shade must be equal\n");
	       npoint = (npoint < yyvsp[0].vector.dimen) ? npoint : yyvsp[0].vector.dimen;
	    }
	    if(yyvsp[-3].intval == 1) {
	       (void)sm_shade(yyvsp[-2].intval,yyvsp[-1].vector.vec.f,yyvsp[0].vector.vec.f,npoint);
	    } else if(yyvsp[-3].intval == 2) {
	       (void)shade_hist(yyvsp[-2].intval,yyvsp[-1].vector.vec.f,yyvsp[0].vector.vec.f,npoint);
	    } else {
	       msg("Unknown shading command\n");
	    }
	    vec_free(&yyvsp[-1].vector); vec_free(&yyvsp[0].vector);
	 ;
    break;}
case 224:
/* #line 1998 "control.y" */
{ sm_draw_surface(yyvsp[-2].intval,yyvsp[-1].floatval,yyvsp[0].floatval,(REAL *)NULL,0,(REAL *)NULL,0); ;
    break;}
case 225:
/* #line 2000 "control.y" */
{
	    VECTOR *x,*y;
	    
	    if((x = get_vector_ptr(yyvsp[-1].charval)) == NULL) {
	       break;
	    }
	    if(x->type != VEC_FLOAT) {
	       msg_1s("Error: %s is not an arithmetic vector\n",yyvsp[-1].charval);
	       YYERROR;
	    }
	    if((y = get_vector_ptr(yyvsp[0].charval)) == NULL) {
	       break;
	    }
	    if(y->type != VEC_FLOAT) {
	       msg_1s("Error: %s is not an arithmetic vector\n",yyvsp[0].charval);
	       YYERROR;
	    }
	    sm_draw_surface(yyvsp[-4].intval,yyvsp[-3].floatval,yyvsp[-2].floatval,x->vec.f,x->dimen,y->vec.f,y->dimen);
	 ;
    break;}
case 226:
/* #line 2020 "control.y" */
{
	    if(*mgets(buff,MACROSIZE) != '\0') {
	       sm_xlabel(&buff[1]);
	    } else {
	       msg("Can't get xlabel\n");
	    }
	 ;
    break;}
case 227:
/* #line 2028 "control.y" */
{
	    if(*mgets(buff,MACROSIZE) != '\0') {
	       sm_ylabel(&buff[1]);
	    } else {
	       msg("Can't get ylabel\n");
	    }
	 ;
    break;}
case 228:
/* #line 2038 "control.y" */
{ yyval.intval = yyvsp[0].intval; ;
    break;}
case 229:
/* #line 2040 "control.y" */
{ yyval.intval = -yyvsp[0].intval; ;
    break;}
case 230:
/* #line 2044 "control.y" */
{ yyval.intval = yyvsp[0].intval; ;
    break;}
case 231:
/* #line 2046 "control.y" */
{ yyval.intval = 0; ;
    break;}
case 232:
/* #line 2050 "control.y" */
{
	    int i;
	    float diff,min,max;

	    if(fabs(x_range) < 1e-20 && fabs(y_range) < 1e-20) {
	       min = 1e30; max = -1e30;
	       for(i = 0;i < yyvsp[0].vector.dimen;i++) {
	          if(yyvsp[0].vector.vec.f[i] < NO_VALUE) { /* not a bad point */
		     if(yyvsp[0].vector.vec.f[i] > max) {
		        max = yyvsp[0].vector.vec.f[i];
		     }
		     if(yyvsp[0].vector.vec.f[i] < min) {
		        min = yyvsp[0].vector.vec.f[i];
		     }
		  }
	       }
	    } else {			/* a range is set for x and/or y */
	       sort_flt(yyvsp[0].vector.vec.f,yyvsp[0].vector.dimen);

	       for(i = yyvsp[0].vector.dimen - 1;i >= 0;i--) { /* ignore bad points */
	          if(yyvsp[0].vector.vec.f[i] < NO_VALUE) break;
	       }
	       if(i < 0) {
	          msg("No valid values to find limits from");
	          yyval.pairval.a = yyval.pairval.b = yyval.pairval.med = 0.0;
	          break;
	       }

	       min = yyvsp[0].vector.vec.f[0];
	       max = yyvsp[0].vector.vec.f[i];
	       if(i%2 == 0) {
	          yyval.pairval.med = yyvsp[0].vector.vec.f[i/2];
	       } else {
	          yyval.pairval.med = (yyvsp[0].vector.vec.f[i/2] + yyvsp[0].vector.vec.f[i/2 + 1])/2;
	       }
	    }
	    diff = max - min;
	    if(diff == 0) {
	       diff = min;
	    }
	    diff *= 0.05;
	    yyval.pairval.a = min - diff;
	    yyval.pairval.b = max + diff;
	    vec_free(&yyvsp[0].vector);
	 ;
    break;}
case 233:
/* #line 2096 "control.y" */
{
	    yyval.pairval.a = yyvsp[-1].floatval;
	    yyval.pairval.b = yyvsp[0].floatval;
	    yyval.pairval.med = (yyvsp[-1].floatval + yyvsp[0].floatval)/2;
	 ;
    break;}
case 234:
/* #line 2104 "control.y" */
{ yyval.t_list = getlist((TOK_LIST *)NULL); ;
    break;}
case 235:
/* #line 2106 "control.y" */
{
	    if(yyvsp[-1].t_list == NULL) {		/* couldn't get space */
	       break;
	    }
            if(yyvsp[-1].t_list->nitem >= yyvsp[-1].t_list->nmax) {	/* get some more space */
	       yyval.t_list = getlist(yyvsp[-1].t_list);
	    } else {
	       yyval.t_list = yyvsp[-1].t_list;
	    }
	    (void)strncpy(yyval.t_list->i_list[yyval.t_list->nitem]->str,yyvsp[0].charval,CHARMAX);
	    yyval.t_list->nitem++;
	 ;
    break;}
case 236:
/* #line 2119 "control.y" */
{
	    if(yyvsp[-1].t_list == NULL) {		/* couldn't get space */
	       break;
	    }
            if(yyvsp[-1].t_list->nitem >= yyvsp[-1].t_list->nmax) {	/* get some more space */
	       yyval.t_list = getlist(yyvsp[-1].t_list);
	    } else {
	       yyval.t_list = yyvsp[-1].t_list;
	    }
	    (void)strncpy(yyval.t_list->i_list[yyval.t_list->nitem]->str,yyvsp[0].charval,CHARMAX);
	    yyval.t_list->nitem++;
	 ;
    break;}
case 237:
/* #line 2132 "control.y" */
{
	    if(yyvsp[-1].t_list == NULL) {		/* couldn't get space */
	       break;
	    }
            if(yyvsp[-1].t_list->nitem >= yyvsp[-1].t_list->nmax) {	/* get some more space */
	       yyval.t_list = getlist(yyvsp[-1].t_list);
	    } else {
	       yyval.t_list = yyvsp[-1].t_list;
	    }
	    (void)strncpy(yyval.t_list->i_list[yyval.t_list->nitem]->str,"\n",CHARMAX);
	    yyval.t_list->nitem++;
	 ;
    break;}
case 238:
/* #line 2147 "control.y" */
{ yyval.floatval = yyvsp[-1].intval ? -yyvsp[0].floatval : yyvsp[0].floatval; ;
    break;}
case 239:
/* #line 2149 "control.y" */
{ yyval.floatval = yyvsp[-1].intval ? -yyvsp[0].intval : yyvsp[0].intval; ;
    break;}
case 240:
/* #line 2151 "control.y" */
{ yyval.floatval = yyvsp[-1].vector.dimen; vec_free(&yyvsp[-1].vector); ;
    break;}
case 241:
/* #line 2153 "control.y" */
{
	    int i;
	    double val;			/* $$ is a float */

	    val = 0;
	    for(i = 0;i < yyvsp[-1].vector.dimen;i++) {
	       val += yyvsp[-1].vector.vec.f[i];
	    }
	    yyval.floatval = val;
	    vec_free(&yyvsp[-1].vector);
	 ;
    break;}
case 242:
/* #line 2165 "control.y" */
{
	    int i,tok,vtype;
	    YYSTYPE lval;

	    i = 0;
	    if(yyvsp[-1].charval[0] == '-') {		/* could be part of -number */
	       if(yyvsp[-1].charval[1] == '.' || isdigit(yyvsp[-1].charval[1])) {
		  i = 1;		/* assume it is, this could be wrong */
	       }
	    }
	    push(&yyvsp[-1].charval[i],S_NORMAL);
#if defined(YYBISON)		/* a bison later than 1.14 */
	    tok = yylex(&lval);		/* convert word to a token */
#else
	    tok = yylex(&lval,(Void *)NULL); /* convert word to a token */
#endif
	    unsave_str();		/* yylex will have saved it */
	    if(tok == INTEGER || tok == FLOAT) {
	       i = 0;
	    } else {					/* a word */
	       i = 01;
	       if(get_macro(yyvsp[-1].charval,(int *)NULL,(int *)NULL,(int *)NULL)
			         != NULL) i |= 02;	/* a macro */
	       if(*print_var(yyvsp[-1].charval) != '\0') i |= 04;	/* a variable */
	       if((vtype = is_vector(yyvsp[-1].charval)) != 0) {
		  i |= 010;		/* a vector */
		  if(vtype == VEC_FLOAT) {
		     i |= 040;
		  } else if(vtype == VEC_STRING) {
		     i |= 0100;
		  }
	       }
	       if(tok != WORD) i |= 020;		/* a keyword */
	    }
	    yyval.floatval = i;
	 ;
    break;}
case 243:
/* #line 2204 "control.y" */
{ (void)sprintf(yyval.charval,"%.10g",yyvsp[0].floatval); ;
    break;}
case 244:
/* #line 2206 "control.y" */
{ (void)strcpy(yyval.charval,yyvsp[0].charval); ;
    break;}
case 245:
/* #line 2210 "control.y" */
{ yyval.floatval = 1; ;
    break;}
case 246:
/* #line 2212 "control.y" */
{ yyval.floatval = yyvsp[0].floatval; ;
    break;}
case 247:
/* #line 2216 "control.y" */
{
	    int type;

	    if((type = get_vector(yyvsp[0].charval,&yyval.vector)) < 0) {
	       break;
	    } else if(type == VEC_STRING) {
	       msg_1s("%s is not an arithmetic vector\n",yyvsp[0].charval);
	       break;
	    }
	 ;
    break;}
case 248:
/* #line 2227 "control.y" */
{ yyval.vector = yyvsp[-1].vector; yyval.vector.name = "(expr)"; ;
    break;}
case 249:
/* #line 2231 "control.y" */
{ yyval.intval = CONNECT; ;
    break;}
case 250:
/* #line 2233 "control.y" */
{ yyval.intval = HISTOGRAM; ;
    break;}
case 251:
/* #line 2235 "control.y" */
{ yyval.intval = POINTS; ;
    break;}
case 252:
/* #line 2239 "control.y" */
{ yyval.intval = '+'; ;
    break;}
case 253:
/* #line 2241 "control.y" */
{ yyval.intval =  ' '; ;
    break;}
case 254:
/* #line 2245 "control.y" */
{
	    if((yyval.strval.start = malloc(1)) != NULL) {
	       yyval.strval.start[0] = '\0';
	       yyval.strval.end = yyval.strval.start;
	    }
	 ;
    break;}
case 255:
/* #line 2252 "control.y" */
{ yyval.strval = yyvsp[0].strval; ;
    break;}
case 256:
/* #line 2256 "control.y" */
{ yyval.intval = 1; ;
    break;}
case 257:
/* #line 2258 "control.y" */
{ yyval.intval = 0; ;
    break;}
case 258:
/* #line 2260 "control.y" */
{ yyval.intval = 0; ;
    break;}
case 259:
/* #line 2264 "control.y" */
{
	    if(yyvsp[0].vector.dimen <= 0) {
	       msg_1s("Vector %s has dimension <= 0\n",yyvsp[0].vector.name);
	       YYERROR;
	    } else if(yyvsp[0].vector.dimen != 1 && sm_verbose > 1) {
	       msg_1s("Vector %s must be a scalar\n",yyvsp[0].vector.name);
	    }
	    if(yyvsp[0].vector.type != VEC_FLOAT && sm_verbose > 1) {
	       msg_1s("Error: %s is not an arithmetic vector\n",yyvsp[0].vector.name);
	       vec_free(&yyvsp[0].vector);
	       YYERROR;
	    }
	    yyval.floatval = yyvsp[0].vector.vec.f[0];
	    vec_free(&yyvsp[0].vector);
	 ;
    break;}
case 260:
/* #line 2282 "control.y" */
{ yyval.vector = yyvsp[0].vector; ;
    break;}
case 261:
/* #line 2284 "control.y" */
{
	    int i,j;

	    if(yyvsp[-1].vector.dimen != yyvsp[-4].vector.dimen) {
	       msg_1s("Setting %s: ",yyvsp[-6].charval);
	       msg_2s("Logical vector %s has a different length from %s\n",
		      yyvsp[-1].vector.name, yyvsp[-4].vector.name);
	    }

	    for(i = 0,j = 0;i < yyvsp[-4].vector.dimen;i++) {
	       if(i > yyvsp[-1].vector.dimen || yyvsp[-1].vector.vec.f[i]) { /* copy acceptable elements */
		  if(yyvsp[-4].vector.type == VEC_FLOAT) {
		     yyvsp[-4].vector.vec.f[j] = yyvsp[-4].vector.vec.f[i];
		  } else if(yyvsp[-4].vector.type == VEC_STRING) {
		     (void)strncpy(yyvsp[-4].vector.vec.s.s[j],yyvsp[-4].vector.vec.s.s[i],VEC_STR_SIZE);
		  }
		  j++;
	       }
	    }
	    vec_free(&yyvsp[-1].vector);

	    if((yyvsp[-4].vector.dimen = j) == 0 && sm_verbose > 0) {
	       msg_1s("Vector %s has no elements\n",yyvsp[-6].charval);
	    }
	    if(vec_realloc(&yyvsp[-4].vector,yyvsp[-4].vector.dimen) < 0) {
	       msg_1s("Can't reclaim storage for %s\n",yyvsp[-6].charval);
	       break;
	    }
	    yyval.vector = yyvsp[-4].vector;
	 ;
    break;}
case 262:
/* #line 2315 "control.y" */
{
	    if(make_anon_vector(&yyval.vector,0,VEC_NULL) != 0) {
	       break;
	    }
	    if(vec_do(&yyval.vector, yyvsp[-3].floatval, yyvsp[-1].floatval, yyvsp[0].floatval) < 0) {
	       break;
	    }
	 ;
    break;}
case 263:
/* #line 2326 "control.y" */
{
	    char c;
	    int i;
	    
	    while(c = input(), isspace(c)) continue;
	    (void)unput(c);			/* one too far */

	    for(i = 0;i < CHARMAX - 1;) {
	       if((c = input()) != ')' && !isspace(c)) {
	          yyval.charval[i++] = c;
	       } else {
		  (void)unput(c);
		  break;
	       }
	    }
	    yyval.charval[i] = '\0';
	    if(i == 0) {
	       msg("Error: empty name\n");
	       YYERROR;
	    }
	    save_str(yyval.charval);
            if(sm_verbose > 3) {
               msg_1d("%d> WORD     ",noexpand);
               msg_1s("%s\n",yyval.charval);
	    }
	 ;
    break;}
case 264:
/* #line 2355 "control.y" */
{
	    (void)more((char *)NULL);	/* initialise more */
	    list_internal_vars();
         ;
    break;}
case 265:
/* #line 2360 "control.y" */
{
	    (void)more((char *)NULL);	/* initialise more */
	    if(sm_verbose > 1) {
	       more("Internal variables:\n");
	       list_internal_vars();
	       more("\nUser variables:\n");
	    }
            (void)varlist(0,255);
            (void)unput('\n');
         ;
    break;}
case 266:
/* #line 2371 "control.y" */
{
	    (void)more((char *)NULL);	/* initialise more */
	    (void)varlist(yyvsp[-1].charval[0],yyvsp[0].charval[0]);
	 ;
    break;}
case 267:
/* #line 2376 "control.y" */
{
	    char *ptr;
	    
	    (void)mgets(buff,CHARMAX);	/* read rest of line */
	    for(ptr = buff;*ptr != '\0' && isspace(*ptr);ptr++) {
	       continue;
	    }
	    stg_list(ptr);
	 ;
    break;}
case 268:
/* #line 2386 "control.y" */
{ list_edit(); ;
    break;}
case 269:
/* #line 2388 "control.y" */
{
            (void)macrolist('\0','\177');
            (void)unput('\n');
         ;
    break;}
case 270:
/* #line 2393 "control.y" */
{ (void)macrolist(yyvsp[-1].charval[0],yyvsp[0].charval[0]); ;
    break;}
case 271:
/* #line 2395 "control.y" */
{
	    if(subtable < 0) {
	       msg("You don't have a current table\n");
	    } else {
	       if(subtable == 0) {
		  *word = '\0';
	       } else {
		  sprintf(word,"[%d]",subtable);
	       }
	       sprintf(buff,"Table %s%s, format %s:\n\n",
		       data_file,word,table_fmt);
	       more((char *)NULL);
	       more(buff);

	       list_table_cols(table_fmt);
	    }
	 ;
    break;}
case 272:
/* #line 2413 "control.y" */
{ list_vectors(); ;
    break;}
case 273:
/* #line 2417 "control.y" */
{
	    char *ptr;			/* pointer to $$ */
	    int brace_level,		/* nesting of braces */
	        l_delim,r_delim;	/* left and right delimiters */
	    unsigned int size;		/* size allocated for $$ */

	    if((l_delim = *(yyvsp[0].charval)) == '{') {
	       r_delim = '}';
	    } else if(l_delim == '<') {
	       r_delim = '>';
	    } else {
	       msg_1d("Unknown delimiter %c\n",l_delim);
	       yyval.strval.start = NULL;
	       break;
	    }

	    size = 500;
	    if((yyval.strval.start = malloc(size + 1)) == NULL) { /* extra 1 for '\0' */
	       msg("Can't allocate storage for list\n");
	       break;
	    }

	    for(brace_level = 0,ptr = yyval.strval.start;!sm_interrupt;ptr++) {
	       *ptr = input();
	       if(*ptr == r_delim) {
		  if(brace_level == 0) {
		     break;
		  } else {
		     brace_level--;
		  }
	       } else if(*ptr == l_delim) {
		  brace_level++;
	       }
	       if(ptr >= yyval.strval.start + size - 1) {
		  size *= 2;
		  if((yyval.strval.start = realloc(yyval.strval.start,size + 1)) == NULL) {
		     msg("Can't reallocate storage for do loop\n");
		     goto failed;
		  }
		  ptr = yyval.strval.start + size/2 - 1;
	       }
	    }
	    yyval.strval.end = ptr;
	    *(yyval.strval.end) = '\n';
	    *(yyval.strval.end + 1) = '\0';

	    (void)unput(r_delim);
	    save_str("(str_list)");
	    if(sm_verbose > 3) {
	       if(sm_verbose > 4) {
		  msg_1d("%d> (str_list :\n",noexpand);
		  msg_1s("\t%s",yyval.strval.start);
	       } else {
		  msg_1d("%d> (str_list)\n",noexpand);
	       }
	    }
	    break;
	    failed: ;			/* break out after failed realloc */
	 ;
    break;}
case 274:
/* #line 2478 "control.y" */
{
	    char *ptr,*str;
	    
	    str = yyvsp[0].charval; str++;		/* strip opening ' */
	    for(ptr = yyval.charval;*str != '\0';) {
	       if(*str == '\\') {
		  str++;
		  switch (*str) {
		   case '\\': *ptr++ = '\\'; break;
		   case '\'': *ptr++ = '\''; break;
		   case 'n': *ptr++ = '\n'; break;
		   case 'r': *ptr++ = '\r'; break;
		   case 't': *ptr++ = '\t'; break;
		   default:
		     msg_1d("Unknown escape sequence in format: \\%c\n",*str);
		     *ptr++ = *str;
		     break;
		  }
		  if(*str != '\0') str++;
	       } else {
		  *ptr++ = *str++;
	       }
	    }
	    *(ptr - 1) = '\0';		/* strip closing ' */
	 ;
    break;}
case 275:
/* #line 2504 "control.y" */
{
	    VECTOR *temp;
		     
	    if((temp = get_vector_ptr(yyvsp[-1].charval)) == NULL) {
	       break;
	    }
	    yyval.charval[CHARMAX - 1] = '\0';
	    strncpy(yyval.charval,temp->descrip,CHARMAX - 1);
	 ;
    break;}
case 276:
/* #line 2516 "control.y" */
{ yyval.charval[0] = '\0'; ;
    break;}
case 277:
/* #line 2518 "control.y" */
{ (void)strcpy(yyval.charval,yyvsp[0].charval); ;
    break;}
case 278:
/* #line 2522 "control.y" */
{
	    char c;
	    int i;
	    
	    while(c = input(), isspace(c)) continue;
	    (void)unput(c);			/* one too far */

	    for(i = 0;i < CHARMAX - 1;) {
	       if((c = input()) == '_' || isalnum(c)) {
	          variable_name[i++] = c;
	       } else {
		  (void)unput(c);
		  break;
	       }
	    }
	    variable_name[i] = '\0';
	    if(i == 0) {
	       msg("Error: empty variable name\n");
	       YYERROR;
	    }
	    save_str(variable_name);
            if(sm_verbose > 3) {
               msg_1d("%d> WORD     ",noexpand);
               msg_1s("%s\n",variable_name);
	    }
	 ;
    break;}
case 279:
/* #line 2551 "control.y" */
{ if(variable_name[0] != '\0') setvar(variable_name,"delete"); ;
    break;}
case 280:
/* #line 2553 "control.y" */
{ if(variable_name[0] != '\0') make_local_variable(variable_name); ;
    break;}
case 281:
/* #line 2555 "control.y" */
{
	    if(yyvsp[0].strval.start == NULL) break;
	    *(yyvsp[0].strval.end) = '\0';		/* remove '\n' */
	    if(variable_name[0] != '\0') setvar(variable_name,yyvsp[0].strval.start);
            free(yyvsp[0].strval.start);
	 ;
    break;}
case 282:
/* #line 2562 "control.y" */
{
	    if(variable_name[0] != '\0') {
	       setvar(variable_name,read_image_variable(variable_name));
	    }
	 ;
    break;}
case 283:
/* #line 2568 "control.y" */
{
	    char *temp;

	    if(variable_name[0] == '\0' ||
			      (temp = read_variable(data_file,yyvsp[0].intval,0)) == NULL) {
	       break;
	    }
	    setvar(variable_name,temp);
	 ;
    break;}
case 284:
/* #line 2578 "control.y" */
{
	    char *temp;

	    if(variable_name[0] == '\0' ||
			     (temp = read_variable(data_file,yyvsp[-1].intval,yyvsp[0].intval)) == NULL) {
	       break;
	    }
	    setvar(variable_name,temp);
	 ;
    break;}
case 285:
/* #line 2588 "control.y" */
{ if(variable_name[0] != '\0') setvar(variable_name,yyvsp[0].charval); ;
    break;}
case 286:
/* #line 2590 "control.y" */
{
	    char *temp;

	    if(variable_name[0] != '\0') {
	       if((temp = get_val(variable_name)) != NULL) {
		  setvar(variable_name,temp);
	       } else {
		  if(sm_verbose > 1)
		     msg_1s("%s is not defined in the environment file\n",
								variable_name);
	       }
	    }
	 ;
    break;}
case 287:
/* #line 2604 "control.y" */
{
	    char *oldval;		/* old value of variable */

	    if(variable_name[0] == '\0' || yyvsp[0].strval.start == NULL) {
	       if(yyvsp[0].strval.start != NULL) free(yyvsp[0].strval.start);
	       break;
	    }
	    *(yyvsp[0].strval.end) = '\0';		/* remove '\n' */
	    
	    if(graph_mode) { IDLE(); graph_mode = 0; }
	    
	    oldval = print_var(variable_name);
	    for(;;) {
	       if(yyvsp[0].strval.start[0] == '\0') {
		  printf("%s ? [%s] ",variable_name,oldval);
	       } else {			/* use prompt specified */
		  printf("%s [%s] ",yyvsp[0].strval.start,oldval);
	       }
	       fflush(stdout);
	       (void)fgets(word,CHARMAX,stdin); word[strlen(word) - 1] = '\0';
	       if(logfil != NULL) fprintf(logfil,"%s\n",word);
	       if(word[0] != '\0') {	/* new value */
		  setvar(variable_name,word);
		  break;
	       } else if(oldval[0] == '\0') {
		  printf("There is no default value for %s\n",variable_name);
		  fflush(stdout);
	       } else {			/* keep old value */
		  break;
	       }
	    }
	    free(yyvsp[0].strval.start);
	    if(in_graphics) { ENABLE(); graph_mode = 1; }
	 ;
    break;}
case 288:
/* #line 2639 "control.y" */
{
	    int i;
	    
	    if(variable_name[0] != '\0') {
	       if((i = index_variable(variable_name)) < 0) {
		  msg_1s("%s is not a valid internal variable\n",variable_name);
		  break;
	       }
	       setvar(variable_name,get_variable(i));
	    }
	 ;
    break;}
case 289:
/* #line 2651 "control.y" */
{
	    if(variable_name[0] != '\0') {
	       if(yyvsp[-1].vector.dimen <= 0 || yyvsp[-1].vector.type == VEC_NULL) {
		  msg_1s("vector %s has no value\n",yyvsp[-1].vector.name);
		  break;
	       }
	       if(yyvsp[-1].vector.type == VEC_STRING) {
		  setvar(variable_name,yyvsp[-1].vector.vec.s.s[0]);
	       } else {
		  (void)sprintf(buff,"%.10g",yyvsp[-1].vector.vec.f[0]);
		  setvar(variable_name,buff);
	       }
	       vec_free(&yyvsp[-1].vector);
	    }
	 ;
    break;}
case 290:
/* #line 2669 "control.y" */
{ yyval.charval[0] = '\0'; ;
    break;}
case 291:
/* #line 2671 "control.y" */
{ (void)strcpy(yyval.charval,yyvsp[0].charval); ;
    break;}
}
   /* the action file gets copied in in place of this dollarsign */
/* #line 303 "bison.simple" */

  yyvsp -= yylen;
  yylsp -= yylen;
  yyssp -= yylen;

  if (yydebug)
    {
      short *ssp1 = yyss - 1;
      fprintf (stderr, "state stack now: %d", yyssp-yyss);
      while (ssp1 != yyssp)
	fprintf (stderr, " %d", *++ssp1);
      fprintf (stderr, "\n");
    }

  *++yyvsp = yyval;

  yylsp++;
  if (yylen == 0)
    {
      yylsp->first_line = yylloc.first_line;
      yylsp->first_column = yylloc.first_column;
      yylsp->last_line = (yylsp-1)->last_line;
      yylsp->last_column = (yylsp-1)->last_column;
      yylsp->text = 0;
    }
  else
    {
      yylsp->last_line = (yylsp+yylen-1)->last_line;
      yylsp->last_column = (yylsp+yylen-1)->last_column;
    }

  /* Now "shift" the result of the reduction.
     Determine what state that goes to,
     based on the state we popped back to
     and the rule number reduced by.  */

  yyn = yyr1[yyn];

  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
    yystate = yytable[yystate];
  else
    yystate = yydefgoto[yyn - YYNTBASE];

  goto yynewstate;

yyerrlab:   /* here on detecting error */

  if (! yyerrstatus)
    /* If not already recovering from an error, report this error.  */
    {
      yyerror("parse error");
    }

  if (yyerrstatus == 3)
    {
      /* if just tried and failed to reuse lookahead token after an error, discard it.  */

      /* return failure if at end of input */
      if (yychar == YYEOF)
	YYERROR;

      if (yydebug)
	fprintf(stderr, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);

      yychar = YYEMPTY;
    }

  /* Else will try to reuse lookahead token
     after shifting the error token.  */

  yyerrstatus = 3;		/* Each real token shifted decrements this */

  goto yyerrhandle;

yyerrdefault:  /* current state does not do anything special for the error token. */

#if 0
  /* This is wrong; only states that explicitly want error tokens
     should shift them.  */
  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
  if (yyn) goto yydefault;
#endif

yyerrpop:   /* pop the current state because it cannot handle the error token */

  if (yyssp == yyss) YYERROR;
  yyvsp--;
  yylsp--;
  yystate = *--yyssp;

  if (yydebug)
    {
      short *ssp1 = yyss - 1;
      fprintf (stderr, "Error: state stack now: %d", yyssp-yyss);
      while (ssp1 != yyssp)
	fprintf (stderr, " %d", *++ssp1);
      fprintf (stderr, "\n");
    }

yyerrhandle:

  yyn = yypact[yystate];
  if (yyn == YYFLAG)
    goto yyerrdefault;

  yyn += YYTERROR;
  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
    goto yyerrdefault;

  yyn = yytable[yyn];
  if (yyn < 0)
    {
      if (yyn == YYFLAG)
	goto yyerrpop;
      yyn = -yyn;
      goto yyreduce;
    }
  else if (yyn == 0)
    goto yyerrpop;

  if (yyn == YYFINAL)
    YYACCEPT;

  if (yydebug)
    fprintf(stderr, "Shifting error token, ");

  *++yyvsp = yylval;
  *++yylsp = yylloc;

  yystate = yyn;
  goto yynewstate;
}
/* #line 2674 "control.y" */
					/* start of programmes */

void
yyerror(s)
char s[];
{
   char *cmacro,			/* which macro are we in? */
	*lline;				/* pointer to last line */
   int i,
       offset;				/* offset of last token in line */

   if(strcmp(s,"syntax error") != 0 &&			/* Yacc message */
		 	strcmp(s,"parse error") != 0 &&	/* Bison message */
		 	strcmp(s,"misc error") != 0 &&	/* our message */
		 	strcmp(s,"show where") != 0) {	/* display command */
      msg_1s("%s in control.y\n",s);
   } else {				/* Syntax Error */
      if(graph_mode) { IDLE(); graph_mode = 0; }
      lline = get_line(&offset);
      if(!strcmp(s,"misc error")) {	/* a private (not yacc) message */
	 fprintf(stderr,"Error at \"%s\"",&lline[offset]);
      } else if(!strcmp(s,"show where")) { /* just print current command */
	 if(!sm_verbose) {
	    fprintf(stderr,"\n");
	    return;
	 }
	 fprintf(stderr," at \"%s\"",&lline[offset]);
      } else if(strcmp(lline,"<user abort>") == 0) { /* a deliberate error */
	 if(*print_var("traceback") != '\0') {
	    dump_stack();
	 }
	 return;
      } else {
	 fprintf(stderr,"Syntax error at \"%s\"",&lline[offset]);
      }
      if((cmacro = current_macro()) == NULL) {
	 fprintf(stderr,"\n");
      } else {
	 fprintf(stderr," in macro %s\n",cmacro);
      }
      fprintf(stderr,"%s\n",lline);
      for(i = 0;i < offset;i++) (void)putc(' ',stderr);
      while(lline[i++] != '\0') (void)putc('^',stderr);
      (void)putc('\n',stderr);
      if(*print_var("traceback") != '\0') {
	 dump_stack();
      }
      if(in_graphics) { ENABLE(); graph_mode = 1; }
   }
}

/*****************************************************************************/
/*
 * enable/disable graphics, setting graph_mode and in_graphics correctly
 *
 * Judicious use of these functions can significantly reduce mode switching
 */
void
sm_enable()
{
   if(!graph_mode) {
      graph_mode = 1;
      in_graphics = 1;
      ENABLE();
   }
}

void
sm_disable()
{
   if(graph_mode) {
      graph_mode = 0;
      in_graphics = 0;
      IDLE();
   }
}

/****************************************************/
/*
 * Print a string on stdout, after dealing with graph mode
 */
void
msg(fmt)
char *fmt;			/* message to print */
{
   if(graph_mode) { IDLE(); graph_mode = 0; }
   printf(fmt); fflush(stdout);
   if(in_graphics) { ENABLE(); graph_mode = 1; }
}

/*
 * Print a string on stdout, with one string argument
 */
void
msg_1s(fmt,s)
char *fmt,			/* message to print */
     *s;
{
   if(graph_mode) { IDLE(); graph_mode = 0; }
   printf(fmt,s); fflush(stdout);
   if(in_graphics) { ENABLE(); graph_mode = 1; }
}


/*
 * Print a string on stdout, with two string arguments
 */
void
msg_2s(fmt,s1,s2)
char *fmt,			/* message to print */
     *s1,*s2;
{
   if(graph_mode) { IDLE(); graph_mode = 0; }
   printf(fmt,s1,s2); fflush(stdout);
   if(in_graphics) { ENABLE(); graph_mode = 1; }
}

/*
 * Print a string on stdout, with one int argument
 */
void
msg_1d(fmt,i)
char *fmt;			/* message to print */
int i;
{
   if(graph_mode) { IDLE(); graph_mode = 0; }
   printf(fmt,i); fflush(stdout);
   if(in_graphics) { ENABLE(); graph_mode = 1; }
}

/*
 * Print a string on stdout, with one float argument
 */
void
msg_1f(fmt,x)
char *fmt;			/* message to print */
double x;
{
   if(graph_mode) { IDLE(); graph_mode = 0; }
   printf(fmt,x); fflush(stdout);
   if(in_graphics) { ENABLE(); graph_mode = 1; }
}

/*
 * Parse a qualifer: e.g. `2.s' -> VEC_STRING
 */
int
parse_qualifier(str)
char *str;
{
   char *ptr;
   
   if((ptr = strrchr(str,'.')) == NULL) {
      return(VEC_FLOAT);
   } else {
      switch (*(ptr + 1)) {
       case 'f':
	 return(VEC_FLOAT);
       case 's':
	 return(VEC_STRING);
       default:
	 msg_1s("unknown type qualifier: %s\n",str);
	 return(VEC_FLOAT);
      }
   }
}
